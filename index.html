<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <!-- æ ¸å¿ƒä¿®æ”¹ï¼šä¼˜åŒ–è§†å£é…ç½®ï¼Œå…¼å®¹PC+ç§»åŠ¨ç«¯ -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<!-- æ–°å¢ï¼šç§»åŠ¨ç«¯å…¨å±/çŠ¶æ€æ é€‚é… -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="mobile-web-app-capable" content="yes">
<meta name="format-detection" content="telephone=no">
<title>MyQæ’çƒçš„è–èª•æ¨¹ä¹‹æ—…</title>

	<!-- ========== è¿™é‡Œæ·»åŠ GA4ç»Ÿè®¡ä»£ç ï¼ˆæ ¸å¿ƒä½ç½®ï¼‰ ========== -->
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-DF0B0FT8TB"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-DF0B0FT8TB'); // æ›¿æ¢æˆä½ çš„GA4æµ‹é‡ID
    </script>
    <!-- ========== GA4ä»£ç ç»“æŸ ========== -->
    <style>
    /* å¼•å…¥è¡¬çº¿å­—ä½“ï¼Œè¥é€ é«˜çº§æ„Ÿ */
    @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600&display=swap');

    /* å…¨å±€å˜é‡ï¼šç»Ÿä¸€é‡‘è‰²å’Œå­—ä½“ */
    :root {
         --gold-primary: #aaddff;    /* æµ…å†°è“ */
        --gold-secondary: #00ffff;  /* å†°é’è‰² */
        --gold-dark: #002244;       /* æ·±æµ·è“ */
        --font-main: 'Cinzel', serif;
		--mobile-breakpoint: 768px;
    }

    /* å…¨å±€åŸºç¡€è®¾ç½® */
    body { 
        margin: 0; 
        overflow: hidden; 
        background-color: #000; 
        font-family: var(--font-main); 
        touch-action: none; /* ç¦æ­¢é»˜è®¤è§¦æ‘¸è¡Œä¸º */
        -webkit-user-select: none; 
        user-select: none; 
		width: 100vw;
    	height: 100vh;
    }
		/* PCç«¯bodyæ ·å¼ï¼ˆå±å¹•>768pxï¼‰ */
@media (min-width: 769px) {
    body {
        touch-action: none; /* PCç«¯ç¦ç”¨è§¦æ‘¸è¡Œä¸º */
    }
}

/* ç§»åŠ¨ç«¯bodyæ ·å¼ï¼ˆå±å¹•â‰¤768pxï¼‰ */
@media (max-width: 768px) {
    body {
        touch-action: manipulation; /* ç§»åŠ¨ç«¯ä¼˜åŒ–è§¦æ‘¸ï¼Œç¦ç”¨åŒå‡»ç¼©æ”¾ */
        -webkit-tap-highlight-color: transparent; /* ç§»é™¤ç§»åŠ¨ç«¯ç‚¹å‡»é«˜äº® */
    }
}

    /* æ ‡é¢˜ - é€šç”¨æ ·å¼ */
#title {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    font-family: var(--font-main);
    color: var(--gold-primary);
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8), 0 0 25px var(--gold-primary), 0 0 5px var(--gold-dark); /* ç†”å²©å‘å…‰é˜´å½± */
    font-weight: bold;
    z-index: 1000;
    text-align: center;
    opacity: 0;
    pointer-events: none;
    transition: opacity 1s ease-in-out;
}

.title-logo {
    height: auto; /* ä¿æŒæ¯”ä¾‹ */
    border-radius: 4px;
    object-fit: contain;
    transition: all 0.3s ease; /* å°ºå¯¸å˜åŒ–æ—¶å¹³æ»‘è¿‡æ¸¡ */
}

/* æ ‡é¢˜ - PCç«¯ */
@media (min-width: 769px) {
    #title {
        top: 15px;
        font-size: 30px;
        letter-spacing: 2px;
    }
    .title-logo {
        width: 130px;
    }
    :fullscreen .title-logo {
        width: 150px;
    }
}

/* æ ‡é¢˜ - ç§»åŠ¨ç«¯ï¼ˆç»Ÿä¸€æ”¾å¤§ï¼Œä¿®å¤å†²çªï¼‰ */
@media (max-width: 768px) {
    #title {
        top: 2vw; /* ä¿ç•™é¡¶éƒ¨è¾¹è·ï¼Œé€‚é…æ‰‹æœº */
        font-size: 5vw; /* ä»3vwæ”¾å¤§åˆ°5vwï¼Œæ ‡é¢˜æ›´é†’ç›® */
        letter-spacing: 0.5vw; /* å­—æ¯é—´è·ç•¥æ”¾å¤§ï¼Œè§†è§‰æ›´èˆ’å±• */
        line-height: 1.2; /* æ–°å¢ï¼šé¿å…æ–‡å­—æ¢è¡Œé‡å  */
    }
    .title-logo {
        width: 20vw; /* æ ¸å¿ƒï¼šä»å†²çªçš„35vw/50pxç»Ÿä¸€ä¸º20vwï¼ˆæ”¾å¤§ä¸”é€‚é…ï¼‰ */
        max-width: 120px; /* æ–°å¢ï¼šé™åˆ¶æœ€å¤§å®½åº¦ï¼Œé¿å…å¤§å±æ‰‹æœºlogoè¿‡å¤§ */
    }
    :fullscreen .title-logo {
        width: 22vw; /* å…¨å±æ—¶logoå†æ”¾å¤§ä¸€ç‚¹ï¼Œé€‚é…å…¨å±åœºæ™¯ */
        max-width: 150px;
    }
}
    /* WebGL å®¹å™¨ */
    #canvas-container { 
        width: 100vw; height: 100vh; 
        position: absolute; top: 0; left: 0; 
        z-index: 1; 
    }
    
    /* UI äº¤äº’å±‚ (å…è®¸ç‚¹å‡»ç©¿é€) */
    #ui-layer {
        position: absolute; top: 0; left: 0; 
        width: 100%; height: 100%;
        z-index: 10; 
        pointer-events: none; 
        background: radial-gradient(circle at center, transparent 0%, rgba(0,34,68,0.7) 100%);
    }

   /* æ“ä½œè¯´æ˜ - é€šç”¨æ ·å¼ */
#ui-layer2 {
    position: absolute;
    z-index: 1000;
    font-family: var(--font-main);
    color: var(--gold-primary);
    line-height: 1.6;
    pointer-events: none;
    opacity: 0;
    transition: opacity 1s ease-in-out; 
}

/* æ“ä½œè¯´æ˜ - PCç«¯ */
@media (min-width: 769px) {
    #ui-layer2 {
        bottom: 20px;
        left: 20px;
        font-size: 16px;
    }
}

/* æ“ä½œè¯´æ˜ - ç§»åŠ¨ç«¯ */
@media (max-width: 768px) {
    #ui-layer2 {
        bottom: 3vw;
        left: 3vw;
        font-size: 3.0vw;
        max-width: 80%; /* é˜²æ­¢æ–‡å­—æº¢å‡º */
    }
}

/* æ˜¾ç¤ºçŠ¶æ€ - é€šç”¨ */
#title.show, #ui-layer2.show {
    opacity: 1;
    pointer-events: auto;
}

    
    /* å¯åŠ¨æŒ‰é’®åŸºç¡€æ ·å¼ï¼ˆæ ¸å¿ƒä¿®å¤ï¼šhover å¤±æ•ˆé—®é¢˜ï¼‰ */
/* å¯åŠ¨æŒ‰é’®åŸºç¡€æ ·å¼ï¼ˆä¸´æ—¶æ¢å¤å¯è§æ€§ï¼‰ */
/* æ™®é€šçŠ¶æ€ */
/* å¯åŠ¨æŒ‰é’® - é€šç”¨æ ·å¼ */
#start-btn {
    position: fixed;
    left: 50%;
    transform: translateX(-50%);
    z-index: 99999;
    background: linear-gradient(135deg, var(--gold-primary) 0%, var(--gold-secondary) 100%);
    color: var(--gold-dark);
    border: 2px solid var(--gold-secondary);
    border-radius: 16px;
    font-weight: 600;
    font-family: var(--font-main);
    cursor: pointer;
    box-shadow: 0 6px 20px rgba(0,255,255,0.6);
    opacity: 1;
    visibility: visible;
    pointer-events: auto;
    transition: all 0.3s ease;
    display: none; /* åˆå§‹éšè— */
}

/* å¯åŠ¨æŒ‰é’® - PCç«¯ */
@media (min-width: 769px) {
    #start-btn {
        bottom: 50px;
        padding: 22px 48px;
        font-size: 20px;
        border-radius: 16px;
    }
    #start-btn:hover {
        background: linear-gradient(135deg, #bbeeff 0%, #00e6e6 100%);
        box-shadow: 0 8px 25px rgba(170,221,255,0.6);
        transform: translateX(-50%) translateY(-3px);
    }
    #start-btn:active {
        transform: translateX(-50%) translateY(1px) scale(0.95);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }
}

/* å¯åŠ¨æŒ‰é’® - ç§»åŠ¨ç«¯ */
@media (max-width: 768px) {
    #start-btn {
        bottom: 6vw;
        padding: 3vw 7vw;
        font-size: 3.5vw;
        border-radius: 3.5vw;
    }
    #start-btn:hover, #start-btn:active {
        background: linear-gradient(135deg, #bbeeff 0%, #00e6e6 100%);
        box-shadow: 0 8px 25px rgba(170,221,255,0.6);
        transform: translateX(-50%) translateY(-0.8vw);
    }
    #start-btn:active {
        transform: translateX(-50%) translateY(0.4vw) scale(0.95);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }
}
		
/* ç»§ç»­æŒ‰é’® hover é€šç”¨ */
#continueBtn:hover {
  background: #00ffff;
  transform: scale(1.05);
  box-shadow: 0 0 20px #aaddff;
}

/* å¥–åŠ±å†»ç»“å±‚ - é€šç”¨æ ·å¼ */
/* å†»ç»“æç¤ºå®¹å™¨ - é€šç”¨é»˜è®¤æ ·å¼ï¼ˆæ ¸å¿ƒï¼šé»˜è®¤éšè—ï¼‰ */
#rewardFreezeOverlay {
    /* é»˜è®¤å®Œå…¨éšè—ï¼Œä¸å å¸ƒå±€ç©ºé—´ */
    display: none !important;
    /* å¤‡é€‰æ–¹æ¡ˆï¼ˆè‹¥éœ€è¦å ç©ºé—´ä½†é€æ˜ï¼‰ï¼šdisplay: flex; opacity: 0; pointer-events: none; */
    position: fixed; /* æ–°å¢ï¼šå›ºå®šå®šä½ï¼Œé¿å…å½±å“é¡µé¢å¸ƒå±€ */
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 9999; /* ç¡®ä¿å±‚çº§è¶³å¤Ÿï¼Œæ˜¾ç¤ºæ—¶åœ¨æœ€ä¸Šå±‚ */
    box-sizing: border-box;
}

/* å†»ç»“æç¤ºæ–‡å­— - é€šç”¨æ ·å¼ */
.freeze-tip {
    color: #aaddff;
    font-family: 'Cinzel', serif;
    text-shadow: 0 0 10px #00ffff;
    letter-spacing: 1px !important;
    margin-bottom: 6vw;
    padding: 2vw 0;
    text-align: center;
}

/* ç»§ç»­æŒ‰é’® - é€šç”¨æ ·å¼ */
.freeze-btn {
    background: #aaddff;
    color: #002244;
    border: none;
    font-family: 'Cinzel', serif;
    font-weight: 600;
    cursor: pointer;
    box-shadow: 0 0 15px #aaddff;
    transition: all 0.3s ease;
    max-width: 80vw;
    display: block;
    margin-left: auto;
    margin-right: auto;
}

/* ç»§ç»­æŒ‰é’® hover/active é€šç”¨æ•ˆæœ */
.freeze-btn:hover {
    background: #00ffff;
    transform: scale(1.05);
    box-shadow: 0 0 20px #aaddff;
}

/* ========== PCç«¯æ ·å¼ï¼ˆå±å¹•>768pxï¼‰ ========== */
@media (min-width: 769px) {
    #rewardFreezeOverlay.show { /* ä»…å½“åŠ .showç±»æ—¶æ˜¾ç¤º */
        display: flex !important;
        justify-content: flex-end;
        align-items: center;
        flex-direction: column;
        padding-bottom: 100px;
        padding-left: 0;
        padding-right: 0;
    }
    .freeze-tip {
        font-size: 24px;
        margin-bottom: -12px;
    }
    .freeze-btn {
        padding: 15px 40px;
        font-size: 20px;
        border-radius: 8px;
    }
}

/* ========== ç§»åŠ¨ç«¯æ ·å¼ï¼ˆå±å¹•â‰¤768pxï¼‰ ========== */
@media (max-width: 768px) {
    #rewardFreezeOverlay.show { /* ä»…å½“åŠ .showç±»æ—¶æ˜¾ç¤º */
        display: flex !important;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        padding-bottom: 0;
        min-height: 100vh;
    }
    .freeze-tip {
        font-size: 5vw;
        margin-bottom: 8vw;
        font-weight: 700;
        margin-top: 98vw;
        transform: none;
    }
    .freeze-btn {
        padding: 3vw 8vw;
        font-size: 4vw;
        border-radius: 2vw;
        width: 40vw;
        margin-top: -5vw;
        transform: none;
    }
}

/* å¥–åŠ±æç¤º - é€šç”¨æ ·å¼ï¼ˆä¿ç•™è§†è§‰æ•ˆæœï¼‰ */
.reward-tip {
  text-align: center;
  font-weight: 800;
  color: #fff9c4;
  text-shadow: 0 0 5px #ffd700, 0 0 10px #ffd700, 0 0 15px #ffd700, 0 0 20px #ffd700, 0 2px 2px #000;
  -webkit-text-stroke: 0.5px #ffc107;
  font-family: 'Cinzel', serif;
  background: radial-gradient(circle, rgba(255,215,0,0.3) 0%, rgba(255,215,0,0) 80%);
  padding: 25px 60px;
  border-radius: 12px;
  letter-spacing: 1.5px;
  transition: opacity 0.3s ease;
}

/* å¥–åŠ±æç¤ºæ–‡å­— - PCç«¯ï¼ˆåŸæœ‰å¤§å°ï¼‰ */
@media (min-width: 769px) {
  .reward-tip-text {
    font-size: 38px !important; /* PCç«¯ä¿ç•™38px */
    display: block;
  }
  .reward-tip {
    padding: 25px 60px;
    letter-spacing: 1.5px;
    border-radius: 12px;
    -webkit-text-stroke: 0.5px #ffc107;
  }
}

/* å¥–åŠ±æç¤ºæ–‡å­— - ç§»åŠ¨ç«¯ï¼ˆç¼©å°å­—ä½“ï¼‰ */
@media (max-width: 768px) {
  .reward-tip-text {
    font-size: 6vw !important; /* ç›¸å¯¹å•ä½ï¼Œé€‚é…æ‰€æœ‰æ‰‹æœºï¼ˆçº¦20-28pxï¼‰ */
    display: block;
	white-space: nowrap;
  }
  .reward-tip {
    padding: 5px 10px; /* å†…è¾¹è·åŒæ­¥ç¼©å° */
    letter-spacing: 1px; /* å­—é—´è·ç¼©å° */
    border-radius: 8px; /* åœ†è§’é€‚é…å°å°ºå¯¸ */
    -webkit-text-stroke: 0.3px #ffc107; /* æè¾¹å˜ç»†ï¼Œé€‚é…å°å­—ä½“ */
    /* å¯é€‰ï¼šé™åˆ¶æœ€å¤§å­—ä½“ï¼Œé¿å…å¤§å±æ‰‹æœºè¿‡å¤§ */
    max-width: 90%;
  }
}		
    /* Loading åŠ¨ç”» - é€šç”¨æ ·å¼ */
#loader {
    position: absolute; 
    top: 0; 
    left: 0; 
    width: 100%; 
    height: 100%;
    background: #000;
    z-index: 100;
    display: flex; 
    flex-direction: column;
    align-items: center; 
    justify-content: center;
    transition: all 1.2s cubic-bezier(0.23, 1, 0.32, 1);
    opacity: 1;
}

#loader.hidden {
    opacity: 0;
    pointer-events: none;
    transform: scale(0.95);
}

.spinner {
    border: 3px solid rgba(170,221,255,0.2);
    border-top: 3px solid var(--gold-primary);
    border-radius: 50%; 
    animation: spin 1.2s ease-in-out infinite;
    position: relative;
}

.spinner::after {
    content: '';
    position: absolute;
    border: 2px solid rgba(0,255,255,0.15);
    border-top: 2px solid var(--gold-secondary);
    border-radius: 50%;
    animation: spin 0.8s ease-in-out reverse infinite;
}

.loader-text {
    color: var(--gold-primary);
    font-weight: 400;
    letter-spacing: 0.5px;
    text-align: center;
    line-height: 1.5;
    max-width: 80%;
    opacity: 0.9;
    font-family: var(--font-main);
}

@keyframes spin { 
    0% { transform: rotate(0deg); } 
    100% { transform: rotate(360deg); } 
}

/* Loading - PCç«¯ */
@media (min-width: 769px) {
    #loader {
        gap: 24px;
    }
    .spinner {
        width: 60px;
        height: 60px;
    }
    .spinner::after {
        top: 5px;
        left: 5px;
        right: 5px;
        bottom: 5px;
    }
    .loader-text {
        font-size: 16px;
    }
}

/* Loading - ç§»åŠ¨ç«¯ */
@media (max-width: 768px) {
    #loader {
        gap: 5vw;
    }
    .spinner {
        width: 15vw;
        height: 15vw;
    }
    .spinner::after {
        top: 1vw;
        left: 1vw;
        right: 1vw;
        bottom: 1vw;
    }
    .loader-text {
        font-size: 3.5vw;
    }
}

    /* å³ä¸Šè§’æ§åˆ¶æŒ‰é’®ç»„ - é€šç”¨æ ·å¼ */
#top-right-controls {
    position: absolute;
    z-index: 30; 
    display: flex; 
    flex-direction: column;
    gap: 15px;
    pointer-events: auto;
}

.control-btn {
    background: rgba(0,34,68,0.8);
    border: 1px solid rgba(170,221,255,0.6);
    color: var(--gold-primary); 
    width: 100px; 
    height: auto;
    padding: 10px 0;
    border-radius: 12px;
    display: flex; 
    align-items: center; 
    justify-content: center;
    font-family: var(--font-main);
    font-weight: 600;
    letter-spacing: 1px;
    cursor: pointer;
    backdrop-filter: blur(5px);
    transition: all 0.3s ease;
    box-shadow: 0 0 10px rgba(170,221,255,0.2);
    outline: none; 
    -webkit-tap-highlight-color: transparent;
}

.control-btn:hover {
    background: rgba(170,221,255,0.3);
    border-color: rgba(0,255,255,0.8);
    box-shadow: 0 0 20px rgba(0,255,255,0.4);
    transform: scale(1.05); 
    color: #fff;
}


.control-btn:active { 
    transform: scale(0.95); 
}

/* å³ä¸Šè§’æŒ‰é’® - PCç«¯ */
@media (min-width: 769px) {
    #top-right-controls {
        top: 20px;
        right: 20px;
        gap: 15px;
    }
    .control-btn {
        width: 100px;
        padding: 10px 0;
        font-size: 14px;
        border-radius: 12px;
    }
}

/* å³ä¸Šè§’æŒ‰é’® - ç§»åŠ¨ç«¯ */
@media (max-width: 768px) {
    #top-right-controls {
        top: 3vw;
        right: 3vw;
        gap: 2vw;
    }
    .control-btn {
        width: 25vw;
        padding: 2vw 0;
        font-size: 3.5vw;
        border-radius: 2vw;
    }
}

    /* éšè—çš„æ–‡ä»¶è¾“å…¥æ¡† */
#file-input { display: none; }

/* æ‘„åƒå¤´é¢„è§ˆçª— - é€šç”¨æ ·å¼ */

#webcam-wrapper {
    position: fixed !important; 
    bottom: 3vw !important;
    right: 3vw !important;
    opacity: 0; 
    pointer-events: none;
    border: 1px solid rgba(170, 221, 255, 0.7) !important;
    border-radius: 1.5vw !important;
    background: #002244 !important; 
    z-index: 9999 !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    /* æ ¸å¿ƒï¼šå¼ºåˆ¶é™åˆ¶æœ€å¤§å°ºå¯¸ï¼Œæœç»è¶…å¤§ */
    max-width: 80px !important;  /* æ‰‹æœºç«¯æœ€å¤§80pxå®½ */
    max-height: 120px !important; /* æ‰‹æœºç«¯æœ€å¤§120pxé«˜ */
    overflow: hidden !important;  /* é˜²æ­¢å†…å®¹æº¢å‡º */
}

#webcam-wrapper.show {
    opacity: 1 !important;
    pointer-events: auto !important;
    transform: scale(1) !important;
}

#webcam { display: none !important; }

/* å…³é”®ï¼šè®©é¢„è§ˆç”»é¢é€‚é…wrapperå°ºå¯¸ï¼Œä¸æ’‘å¤§å®¹å™¨ */
#webcam-preview {
    display: block !important;
    width: 100% !important;
    height: 100% !important;
    object-fit: cover !important; /* ç”»é¢å¡«å……å®¹å™¨ï¼Œä¸æ‹‰ä¼¸ */
    transform: scaleX(-1) !important;
}

/* PCç«¯æ ·å¼ï¼ˆç¼©å°ç‰ˆï¼‰ */
@media (min-width: 769px) {
    #webcam-wrapper {
        width: 150px !important;    /* ä»200pxç¼©å°åˆ°150pxï¼ˆæ ¸å¿ƒï¼‰ */
        height: 210px !important;   /* æŒ‰åŸ3:4.2æ¯”ä¾‹åŒæ­¥ç¼©å°ï¼ˆ200:280=150:210ï¼‰ */
        max-width: none !important; /* å–æ¶ˆPCç«¯æœ€å¤§å°ºå¯¸é™åˆ¶ */
        max-height: none !important;
        bottom: 20px !important;
        right: 20px !important;
        border-radius: 6px !important; /* åœ†è§’ç¨è°ƒå¤§ï¼Œé€‚é…å°å°ºå¯¸æ›´åè°ƒ */
    }
}

/* ç§»åŠ¨ç«¯æ ·å¼ - å¼ºåˆ¶å°å°ºå¯¸ */
@media (max-width: 768px) {
    #webcam-wrapper.show {
        width: 10vw !important;    /* åŸºç¡€å®½åº¦10vw */
        aspect-ratio: 3/4 !important; /* å›ºå®šæ¯”ä¾‹ï¼Œé«˜åº¦è‡ªåŠ¨ */
        height: auto !important;
        min-width: 30px !important; /* æœ€å°30pxï¼Œé˜²æ­¢çœ‹ä¸è§ */
        min-height: 40px !important;
    }
}
		
/* ä¸‹è½½æŒ‰é’® - é€šç”¨æ ·å¼ */
.download-btn-container {
    position: fixed;
    left: 50%;
    transform: translateX(-50%);
    z-index: 1000;
}

.download-btn {
    background: linear-gradient(135deg, var(--gold-primary) 0%, var(--gold-secondary) 100%) !important;
    color: var(--gold-dark) !important;
    border: 1px solid var(--gold-secondary) !important;
    cursor: pointer; 
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    position: relative; 
    font-family: var(--font-main);
}

.download-btn:hover { 
    background: linear-gradient(135deg, #ffe100 0%, #f7d100 100%) !important;
}

.close-btn {
    background-color: rgba(0,0,0,0.5) !important;
    color: var(--gold-primary) !important;
    border: none; 
    border-radius: 50%;
    cursor: pointer; 
    display: flex; 
    align-items: center; 
    justify-content: center;
    position: absolute; 
    top: 50%; 
    transform: translateY(-50%);
    line-height: 1;
}

/* ä¸‹è½½æŒ‰é’® - PCç«¯ */
@media (min-width: 769px) {
    .download-btn-container {
        bottom: 20px;
    }
    .download-btn {
        padding: 10px 20px;
        font-size: 14px;
        padding-right: 35px;
        border-radius: 5px;
    }
    .close-btn {
        width: 20px;
        height: 20px;
        font-size: 14px;
        right: 8px;
    }
}

/* ä¸‹è½½æŒ‰é’® - ç§»åŠ¨ç«¯ */
@media (max-width: 768px) {
    .download-btn-container {
        bottom: 3vw;
    }
    .download-btn {
        padding: 2vw 4vw;
        font-size: 3.5vw;
        padding-right: 8vw;
        border-radius: 1vw;
    }
    .close-btn {
        width: 6vw;
        height: 6vw;
        font-size: 4vw;
        right: 2vw;
    }
}

/* é€šç”¨æ ·å¼ */
.hidden { display: none !important; }
@keyframes fadeIn {
    0% { opacity: 0; transform: translateX(-50%) translateY(-10px); }
    100% { opacity: 1; transform: translateX(-50%) translateY(0); }
}
/* ========== æ–°å¢ï¼šåŠ è½½è¿›åº¦æ¡æ ·å¼ ========== */
    #loadingProgressContainer {
    width: 80%; /* é€‚é…loaderå®½åº¦ï¼ŒPC/ç§»åŠ¨ç«¯è‡ªé€‚åº” */
    max-width: 400px; /* é™åˆ¶æœ€å¤§å®½åº¦ */
    display: flex;
    flex-direction: column;
    align-items: center;
    opacity: 1;
    transition: opacity 0.5s ease;
}

/* è¿›åº¦æ¡å¡«å……å±‚ï¼šä¿ç•™ä½ çš„é‡‘è‰²æ¸å˜ï¼Œè°ƒæ•´å°ºå¯¸ */
#loadingProgressBar {
    width: 0%; 
    height: 100%;
    background: linear-gradient(90deg, #aaddff 0%, #00ffff 100%);
    transition: width 0.5s ease-in-out;
    border-radius: 3px;
}

/* è¿›åº¦æ¡èƒŒæ™¯ï¼ˆæ–°å¢ï¼Œè¡¥å…¨è¿›åº¦æ¡å®¹å™¨ï¼‰ */
#loadingProgressContainer::before {
    content: '';
    width: 100%;
    height: 6px;
    background: rgba(170,221,255,0.15);
    border-radius: 3px;
    margin-bottom: 8px;
    display: block;
}

/* ç™¾åˆ†æ¯”æ–‡æœ¬ï¼šä¿ç•™é‡‘è‰²ã€é˜´å½±ï¼Œè°ƒæ•´å®šä½ */
#loadingProgressText {
    color: #aaddff; 
    font-size: 12px; 
    font-family: 'Cinzel', serif; 
    text-shadow: 0 0 5px #00ffff;
    text-align: center;
}

/* è¿›åº¦æ¡å“åº”å¼é€‚é…ï¼ˆåŸºäºä½ çš„åŸæœ‰è§„åˆ™è°ƒæ•´ï¼‰ */
@media (max-width: 768px) {
    #loadingProgressText { font-size: 3vw !important; }
    #loadingProgressContainer::before { height: 4px !important; } /* ç§»åŠ¨ç«¯è¿›åº¦æ¡é«˜åº¦ */
}
@media (min-width: 769px) {
    #loadingProgressText { font-size: 14px !important; }
    #loadingProgressContainer::before { height: 6px !important; } /* PCç«¯è¿›åº¦æ¡é«˜åº¦ */
}
    
</style>

	<!-- 2. GSAP åº“å¼•å…¥ï¼ˆæ–°å¢ï¼Œæ”¾åœ¨æ ·å¼ä¹‹åã€ä¸šåŠ¡JSä¹‹å‰ï¼‰ -->
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>
</head>

<body>
    <!-- åŠ è½½é®ç½©å®¹å™¨ -->
<div id="loader">
    <div class="spinner"></div>
    <div class="loader-text">
        åˆå§‹è¼‰å…¥éœ€è®€å–åœ–ç‰‡å…§å®¹ï¼Œæ•¬è«‹ç¨å€™
    </div>
    <!-- è¿›åº¦æ¡å®¹å™¨ï¼ˆåµŒå…¥loaderå†…éƒ¨ï¼Œä¸å†æ˜¯é¡¶éƒ¨fixedï¼‰ -->
    <div id="loadingProgressContainer" class="progress-container">
        <div id="loadingProgressBar" class="progress-bar-fill"></div>
        <div id="loadingProgressText" class="progress-text">0%</div>
    </div>
</div>


    <div id="canvas-container"></div>
    <!-- æ ‡é¢˜ -->
<div id="title">
    <img id="uploaded-image" src="" alt="Uploaded Image" class="title-logo",style="display: none;">
    <span><br> Wish You Merry Christmas</span>
</div>


    <div id="ui-layer">
        <div id="top-right-controls">
            <button id="btn-fullscreen" class="control-btn">å…¨å±æ¨¡å¼</button>
        </div>
    </div>
	
	<div id="ui-layer2">
    <div class="instruction">âœŠâ†’<b>æ¡æ‹³</b> å¬å–šè–èª•æ¨¹</div>
    <div class="instruction">âœ‹â†’<b>é–‹æŒ</b> æ•£é–‹</div>
	<div class="instruction">ç§»å‹•âœ‹â†’<b>æ»‘å‹•æ‰‹æŒ</b> æ§åˆ¶æ—‹è½‰</div>
    <div class="instruction">ğŸ¤â†’<b>æåˆ</b> æŠ“å–ç¦®ç‰©</div>
</div>

    <div id="webcam-wrapper">
        <video id="webcam" autoplay playsinline webkit-playsinline></video>
        <canvas id="webcam-preview"></canvas>
    </div>
    <!-- å¯åŠ¨æŒ‰é’®ï¼šåº•éƒ¨å±…ä¸­æ˜¾ç¤ºï¼Œé‡‘è‰²ä¸»è‰²è°ƒä¼˜åŒ– -->
<button id="start-btn">
  é–‹å§‹æŒ‘æˆ° <!-- å°ä¿®æ­£ï¼šåŸHOWæ”¹ä¸ºOURæ›´é€šé¡º -->
</button>
    <audio id="bg-music" autoplay loop >
    <source src="./assets/music/How_XMAS_music.ogg" type="audio/ogg">
</audio>
	

    <div class="download-btn-container" id="downloadContainer">
        <button class="download-btn" onclick="downloadHTML()">
            ä¸‹è½½HTMLæ–‡ä»¶
            <button class="close-btn" onclick="closeDownloadBtn(event)" title="å…³é—­">Ã—</button>
        </button>
    </div>

	<!-- ====================== å¥–åŠ±å†»ç»“ç»§ç»­æŒ‰é’® æ·»åŠ åœ¨è¿™é‡Œ ====================== -->
    <div id="rewardFreezeOverlay">
    <div class="freeze-tip">ğŸ“¸ æˆªåœ–æ™‚åˆ»ï¼é»æ“Šç¹¼çºŒ</div>
    <button id="continueBtn" class="freeze-btn">ç¹¼çºŒéŠæˆ²</button>
</div>

	<script>
        let loadingProgress = 0;
        /**
         * æ›´æ–°åŠ è½½è¿›åº¦ï¼ˆä»…ç»Ÿè®¡startBtnæ˜¾ç¤ºå‰çš„åœºæ™¯åŠ è½½ï¼‰
         * @param {number} newProgress ç›®æ ‡è¿›åº¦ï¼ˆ0-100ï¼‰
         * @param {string} text è¿›åº¦æè¿°
         */
        function updateLoadingProgress(newProgress, text = "") {
            loadingProgress = Math.min(Math.max(newProgress, loadingProgress), 100);
            const progressBar = document.getElementById('loadingProgressBar');
            const progressText = document.getElementById('loadingProgressText');
            
            if (progressBar) progressBar.style.width = `${loadingProgress}%`;
            if (progressText) progressText.textContent = `${loadingProgress}% - ${text}`;
            
            // è¿›åº¦100%åéšè—è¿›åº¦æ¡ï¼ˆå’ŒstartBtnæ˜¾ç¤ºåŒæ­¥ï¼‰
            if (loadingProgress === 100) {
                setTimeout(() => {
                    const container = document.getElementById('loadingProgressContainer');
                    if (container) {
                        container.style.opacity = 0;
                        setTimeout(() => container.style.display = 'none', 500);
                    }
                }, 800);
            }
        }
        // åˆå§‹åŒ–è¿›åº¦
        updateLoadingProgress(0);
    </script>
    <!-- ====================== æŒ‰é’®æ·»åŠ ç»“æŸ ====================== -->
</body>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js'; 
        import { FilesetResolver, HandLandmarker, DrawingUtils } from '@mediapipe/tasks-vision';

        // ==========================================
        // 1. CONFIG: å…¨å±€é…ç½®å‚æ•° (æ–¹ä¾¿è°ƒæ•´)
        // ==========================================
        // ==========================================
// 1. CONFIG: å…¨å±€é…ç½®å‚æ•° (æ–¹ä¾¿è°ƒæ•´)
// ==========================================
const CONFIG = {
    colors: {
        bg: 0x000000,        // æ·±æµ·è“ï¼ˆæ›¿æ¢åŸ0x120a00ï¼‰
        gold: 0xaaddff,      // æµ…å†°è“ï¼ˆæ›¿æ¢åŸ0xff4500ï¼‰
        red: 0x00ffff,       // å†°é’è‰²ï¼ˆæ›¿æ¢åŸ0xcc2200ï¼‰
        green: 0x0088aa,     // æµ…è“ç»¿ï¼ˆé€‚é…å†°è“ç³»çš„ç»¿è‰²ï¼‰
        pink: 0xaaddff       // æµ…å†°è“ï¼ˆæ›¿æ¢åŸ0xff8c69ï¼‰
    },
    particles: {
        count: 1800,      // æ ¸å¿ƒç²’å­æ•°
        dustCount: 1500,  // æ°›å›´æ˜Ÿå°˜æ•°
        treeHeight: 28,   // æ ‘é«˜
        treeRadius: 9,     // æ ‘åº•åŠå¾„
		snowCount: 4000   // âœ… æ–°å¢ï¼šé›ªèŠ±ç²’å­æ•°é‡
    },
    camera: {
        z: 55 // åˆå§‹æ‘„åƒæœºè·ç¦»
    },
    gestures: {
        pinchThreshold: 0.05, // æåˆåˆ¤å®šé˜ˆå€¼
        palmOpenThreshold: 0.35, // æ‰‹æŒå¼ å¼€åˆ¤å®šé˜ˆå€¼
        sensitivity: 6.0 // æ‰‹åŠ¿æ—‹è½¬çµæ•åº¦
    }
};

// ==========================================
// æ–°å¢ï¼šç²’å­å½’ä½çŠ¶æ€ç®¡ç†ï¼ˆç‹¬ç«‹å…¨å±€å˜é‡ï¼Œä¸åœ¨CONFIGå†…éƒ¨ï¼‰
// ==========================================
const ANIMATION_STATE = {
    treeSettleComplete: false, // åœ£è¯æ ‘ç²’å­æ˜¯å¦å½’ä½å®Œæˆ
    settleCheckTime: 0,        // å¼€å§‹æ£€æŸ¥å½’ä½çš„æ—¶é—´
    settleThreshold: 0.1,     // å½’ä½åˆ¤å®šé˜ˆå€¼ï¼ˆä½ç½®è¯¯å·®<0.01åˆ™å®Œæˆï¼‰
    settleDelay: 2000          // ç­‰å¾…å½’ä½çš„æœ€å¤§æ—¶é—´ï¼ˆ2ç§’ï¼‰
};
	// ==========================================
// æ–°å¢ï¼šé…ç½®è¯»å– + æœ¬åœ°å›¾ç‰‡åŠ è½½å‡½æ•°
// ==========================================
/**
 * è¯»å–æŒ‡å®šæ–‡ä»¶å¤¹çš„ config.json
 * @param {string} folderPath æ–‡ä»¶å¤¹è·¯å¾„ï¼ˆå¦‚ "./assets/title/"ï¼‰
 * @returns {Promise<Object>} é…ç½®å¯¹è±¡
 */
async function loadConfig(folderPath) {
  try {
    const response = await fetch(`${folderPath}config.json`);
    if (!response.ok) throw new Error(`è¯»å–é…ç½®å¤±è´¥ï¼š${response.status}`);
    return await response.json();
  } catch (err) {
    console.error('é…ç½®è¯»å–å¤±è´¥ï¼š', err);
    return null;
  }
}

/**
 * åŠ è½½æœ¬åœ°å›¾ç‰‡ä¸ºTHREEçº¹ç†
 * @param {string} folderPath æ–‡ä»¶å¤¹è·¯å¾„
 * @param {string} imgName å›¾ç‰‡æ–‡ä»¶å
 * @returns {Promise<THREE.Texture>} çº¹ç†å¯¹è±¡
 */
async function loadLocalTexture(folderPath, imgName) {
  return new Promise((resolve, reject) => {
    const imgPath = `${folderPath}${imgName}`;
    new THREE.TextureLoader().load(
      imgPath,
      (texture) => {
        texture.colorSpace = THREE.SRGBColorSpace;
        resolve(texture);
      },
      undefined,
      (err) => reject(`åŠ è½½å›¾ç‰‡${imgPath}å¤±è´¥ï¼š${err}`)
    );
  });
}

/**
 * åŠ è½½æ ‡é¢˜Logoï¼ˆä» assets/title/config.json è¯»å–ï¼‰
 */
async function loadTitleLogo() {
  const folderPath = "./assets/title/";
  const config = await loadConfig(folderPath);
  if (!config || !config.logo) return;

  // åŠ è½½Logoåˆ°æ ‡é¢˜åŒº
  const logoImg = document.getElementById('uploaded-image');
  logoImg.src = `${folderPath}${config.logo}`;
  logoImg.style.display = 'inline-block';
  console.log('æ ‡é¢˜LogoåŠ è½½å®Œæˆ');
}

/**
 * åŠ è½½çš®å¤´ç…§ç‰‡ï¼ˆä» assets/tip/config.json è¯»å–ï¼‰
 */
async function loadTipPhotos() {
  const folderPath = "./assets/tip/";
  const config = await loadConfig(folderPath);
  if (!config || !config.images || config.images.length === 0) return;

  // éå†é…ç½®ä¸­çš„å›¾ç‰‡ï¼Œç”Ÿæˆçš®å¤´ç²’å­
  for (const imgName of config.images) {
    try {
      const texture = await loadLocalTexture(folderPath, imgName);
      addTipPhotoAsParticles(texture); // å¤ç”¨åŸæœ‰ç²’å­ç”Ÿæˆå‡½æ•°
      console.log(`çš®å¤´ç…§ç‰‡${imgName}åŠ è½½å®Œæˆ`);
    } catch (err) {
      console.error(err);
    }
  }
}

/**
 * åŠ è½½æ•…äº‹ç…§ç‰‡ï¼ˆé€‚é…å¥–åŠ±å›¾ç‰‡ï¼‰
 */
async function loadStoryPhotos() {
  const folderPath = "./assets/story/";
  const config = await loadConfig(folderPath);
  if (!config || (!config.images && !config.rewardImages)) return;

  if (!window.photos) window.photos = [];

  // åŠ è½½æ™®é€šå›¾ç‰‡ï¼ˆåŸæœ‰é€»è¾‘ï¼‰
  if (config.images && config.images.length > 0) {
    for (const imgName of config.images) {
      try {
        const texture = await loadLocalTexture(folderPath, imgName);
        addPhotoToScene(texture, 'NORMAL', 1); 
        console.log(`âœ… æ™®é€šç…§ç‰‡${imgName}åŠ è½½å®Œæˆï¼Œç´¢å¼•ï¼š${window.photos.length-1}`);
      } catch (err) {
        console.error(`âŒ åŠ è½½æ™®é€šç…§ç‰‡${imgName}å¤±è´¥ï¼š`, err);
      }
    }
  }

  // åŠ è½½å¥–åŠ±å›¾ç‰‡ï¼ˆæ–°å¢æ–‡ä»¶è·¯å¾„æ—¥å¿—ï¼‰
if (config.rewardImages && config.rewardImages.length > 0) {
  console.log(`ğŸ“Œ å¾…åŠ è½½å¥–åŠ±å›¾ç‰‡æ•°é‡ï¼š${config.rewardImages.length}`); // å…ˆæ‰“å°æ•°é‡
  for (const rewardItem of config.rewardImages) {
    try {
      const { name: imgName, probability } = rewardItem;
      const fullPath = folderPath + imgName;
      console.log(`ğŸ” å°è¯•åŠ è½½å¥–åŠ±å›¾ç‰‡ï¼š${fullPath}`); // æ‰“å°å®Œæ•´è·¯å¾„
      const validProb = Math.max(0, Math.min(1, probability || 0.1));
      const texture = await loadLocalTexture(folderPath, imgName);
      addPhotoToScene(texture, 'REWARD', validProb); 
      const rewardIndex = window.photos.length - 1;
      console.log(`ğŸ‰ å¥–åŠ±ç…§ç‰‡${imgName}åŠ è½½å®Œæˆï¼Œç´¢å¼•ï¼š${rewardIndex}ï¼Œç±»å‹ï¼š${window.photos[rewardIndex].type}`);
    } catch (err) {
      console.error(`âŒ åŠ è½½å¥–åŠ±ç…§ç‰‡${rewardItem.name}å¤±è´¥ï¼š`, err);
    }
  }
}

  // æœ€ç»ˆæ ¡éªŒï¼šæ‰“å°æ‰€æœ‰ç…§ç‰‡çš„ç´¢å¼•+ç±»å‹+åç§°
  console.log('ğŸ“¸ æ‰€æœ‰ç…§ç‰‡åˆ—è¡¨ï¼š');
  window.photos.forEach((photo, idx) => {
    console.log(`ç´¢å¼•${idx}ï¼šç±»å‹=${photo.type}ï¼Œæ¦‚ç‡=${photo.probability}`);
  });
}

        // ==========================================
        // 2. STATE: è¿è¡Œæ—¶çŠ¶æ€ç®¡ç†
        // ==========================================
        const STATE = {
            mode: 'TREE', // å½“å‰æ¨¡å¼: TREE | SCATTER | HEART | FOCUS
            focusTarget: null, // å½“å‰èšç„¦çš„å¯¹è±¡ (Mesh)
            currentPhotoIndex: -1, // å½“å‰å±•ç¤ºçš„ç…§ç‰‡ç´¢å¼•
            
            // äº¤äº’è¾“å…¥æ•°æ®
            hand: { detected: false, x: 0, y: 0 },
            mouse: { x: 0, y: 0 },
            
            // åŠ¨ç”»çŠ¶æ€
            rotation: { x: 0, y: 0 },
            spinVel: { x: 0, y: 0 }, // æ—‹è½¬é€Ÿåº¦ (x: ä»°ä¿¯, y: å·¦å³)
            time: 0,
            
            // é€»è¾‘è¾…åŠ©
            wasPointing: false, // ä¸Šä¸€å¸§æ˜¯å¦åœ¨æŒ‡ç‚¹
            palmCenter: { x: 0.5, y: 0.5 }, // æ‰‹æŒä¸­å¿ƒåŸºå‡†ç‚¹
            hasPalmCenter: false,
            starMesh: null // æ ‘é¡¶æ˜Ÿæ˜Ÿçš„å¼•ç”¨
        };

        // å…¨å±€å˜é‡
        let scene, camera, renderer, composer;
        let mainGroup, starGroup, bgGroup, photoMeshGroup;
        let clock = new THREE.Clock();
        let particleSystem = []; 
        let handLandmarker, video, drawingUtils, canvasCtx;
        let caneTexture; // ç³–æœæ‹æ–çº¹ç†

        // ==========================================
        // 3. åˆå§‹åŒ–å…¥å£
        // ==========================================
        async function init() {
	updateLoadingProgress(5);    // åˆå§‹åŒ–Three.jsæ ¸å¿ƒ		
    initThree();   
			// åˆå§‹åŒ– Three.js åœºæ™¯
	updateLoadingProgress(10);   // ç¯å¢ƒè´´å›¾è®¾ç½®å®Œæˆ		
    setupEnvironment();   // è®¾ç½®ç¯å¢ƒè´´å›¾
			
	updateLoadingProgress(15);   // ç¯å…‰ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ		
    setupLights();        // è®¾ç½®ç¯å…‰
			
	updateLoadingProgress(20);   // ç¨‹åºåŒ–çº¹ç†ç”Ÿæˆå®Œæˆ		
    createTextures();     // ç”Ÿæˆç¨‹åºåŒ–çº¹ç†

	updateLoadingProgress(25);   // æ˜Ÿç©ºèƒŒæ™¯åˆ›å»ºå®Œæˆ		
    createGalaxyBackground(); // åˆ›å»ºèƒŒæ™¯æ˜Ÿç©º

	createSnowBackground();	
	updateLoadingProgress(30);   // åæœŸå¤„ç†è®¾ç½®å®Œæˆ		
    setupPostProcessing();// è®¾ç½®è¾‰å…‰åæœŸå¤„ç†

	updateLoadingProgress(35);   // DOMäº‹ä»¶ç»‘å®šå®Œæˆ		
    setupEvents();        // ç»‘å®š DOM äº‹ä»¶
    
    // åŠ è½½æ‰€æœ‰å›¾ç‰‡èµ„æº
	updateLoadingProgress(40);   // å¼€å§‹åŠ è½½æ ‡é¢˜Logo		
    await loadTitleLogo();   // åŠ è½½æ ‡é¢˜Logo

	updateLoadingProgress(45);   // å¼€å§‹åŠ è½½çš®å¤´ç…§ç‰‡		
    await loadTipPhotos();   // åŠ è½½çš®å¤´ç…§ç‰‡

	updateLoadingProgress(60);   // å¼€å§‹åŠ è½½æ•…äº‹ç…§ç‰‡	
    await loadStoryPhotos(); // åŠ è½½æ•…äº‹ç…§ç‰‡

    // ========== æ ¸å¿ƒä¿®æ”¹ï¼šç­‰å¾…åœ£è¯æ ‘ç²’å­å®Œå…¨åˆ›å»º ==========
	updateLoadingProgress(90);   // å¼€å§‹åˆ›å»ºåœ£è¯æ ‘ç²’å­		
    await createParticles(); // æ›¿æ¢åŸæ¥çš„åŒæ­¥è°ƒç”¨ï¼Œç­‰ç²’å­åˆ›å»ºå®Œ

	updateLoadingProgress(100);   // å¼€å§‹åˆ›å»ºåœ£è¯æ ‘ç²’å­				

    // ç§»é™¤ Loading é®ç½©
    const loader = document.getElementById('loader');
    loader.style.opacity = 0;
    setTimeout(() => loader.remove(), 1200);

    // ========== å…¨å±€çŠ¶æ€åˆå§‹åŒ– ==========
    window.isSceneStarted = false; // åœºæ™¯æ˜¯å¦å¯åŠ¨
    window.mediaPipeInited = false; // æ‘„åƒå¤´æ˜¯å¦åˆå§‹åŒ–
    const startBtn = document.getElementById('start-btn');
    const bgMusic = document.getElementById('bg-music');
    const musicBtn = document.getElementById('music-play-btn');

    // ========== éŸ³ä¹æ’­æ”¾å‡½æ•° ==========
    const playMusic = () => {
        if (!bgMusic || !window.isSceneStarted) return;
        bgMusic.volume = 0.5;
        bgMusic.load();
        bgMusic.play()
            .then(() => {
                console.log('èƒŒæ™¯éŸ³ä¹æ’­æ”¾æˆåŠŸ');
                if (musicBtn) musicBtn.style.display = 'none';
            })
            .catch(e => {
                console.error('éŸ³ä¹æ’­æ”¾å¤±è´¥ï¼š', e);
                if (musicBtn) musicBtn.style.display = 'block';
            });
    };

    // ========== æ‘„åƒå¤´åˆå§‹åŒ–å‡½æ•°ï¼ˆç‚¹å‡»åæ‰§è¡Œï¼‰ ==========
    const initCameraAndGesture = async () => {
        if (window.mediaPipeInited) return; // é¿å…é‡å¤åˆå§‹åŒ–
        try {
            await initMediaPipe(); // è¯·æ±‚æ‘„åƒå¤´æƒé™
            window.mediaPipeInited = true;
            console.log('æ‘„åƒå¤´åˆå§‹åŒ–æˆåŠŸï¼Œæ‰‹åŠ¿æ§åˆ¶å·²å¼€å¯');
        } catch (e) {
            console.warn('æ‘„åƒå¤´åˆå§‹åŒ–å¤±è´¥ï¼š', e);
            alert('è¯·å…è®¸æ‘„åƒå¤´æƒé™ï¼Œå¦åˆ™æ— æ³•ä½¿ç”¨æ‰‹åŠ¿æ§åˆ¶ï¼');
        }
    };

    // ========== å¯åŠ¨æŒ‰é’®ç‚¹å‡»é€»è¾‘ ==========
    startBtn.addEventListener('click', async () => {
        startBtn.textContent = 'è«‹æ±‚ç›¸æ©Ÿä½¿ç”¨æ¬Šé™ä¸­...';
        startBtn.disabled = true; // ç¦ç”¨æŒ‰é’®ï¼Œé¿å…é‡å¤ç‚¹å‡»

		// ========== âœ… æ–°å¢ï¼šGA4ç»Ÿè®¡ã€Œç‚¹å‡»å¼€å§‹æ¸¸æˆã€äº‹ä»¶ ==========
    if (window.gtag) { // å…¼å®¹ï¼šgtagæœªåŠ è½½æ—¶ä¸æŠ¥é”™
        gtag('event', 'game_start', {
            event_category: 'æ ¸å¿ƒäº¤äº’', // äº‹ä»¶åˆ†ç±»ï¼ˆæ–¹ä¾¿GA4åå°ç­›é€‰ï¼‰
            event_label: 'ç‚¹å‡»StartæŒ‰é’®å¯åŠ¨æ¸¸æˆ', // äº‹ä»¶æ ‡ç­¾ï¼ˆæè¿°è¡Œä¸ºï¼‰
            value: 1 // è®¡æ•°ç”¨ï¼Œå›ºå®šä¼ 1å³å¯
        });
        console.log('ğŸ“Š GA4ï¼šç”¨æˆ·ç‚¹å‡»StartæŒ‰é’®ï¼Œå·²ä¸ŠæŠ¥game_startäº‹ä»¶');
    }
    // ========== GA4ä»£ç ç»“æŸ ==========
        await initCameraAndGesture(); // å…ˆè¯·æ±‚æ‘„åƒå¤´æƒé™
        window.isSceneStarted = true; // è§£é”åŠ¨ç”»/æ‰‹åŠ¿
        startBtn.style.display = 'none'; // éšè—æŒ‰é’®
        playMusic(); // æ’­æ”¾éŸ³ä¹
    });

    // ========== éŸ³ä¹å…œåº•æŒ‰é’® ==========
    if (musicBtn) {
        musicBtn.addEventListener('click', () => {
            if (!window.isSceneStarted) {
                alert('è¯·å…ˆç‚¹å‡»â€œå¼€å§‹ä½“éªŒâ€æŒ‰é’®å¯åŠ¨åœºæ™¯ï¼');
                return;
            }
            playMusic();
        });
    }

    // æ›¿æ¢initå‡½æ•°ä¸­åŸæœ‰çš„â€œå»¶è¿Ÿ+æ¸²æŸ“éªŒè¯â€ä»£ç 
// ========== ç²¾å‡†éªŒè¯ï¼šç²’å­å½’ä½å®Œæˆ + æ¸²æŸ“ç¨³å®šåæ˜¾ç¤ºæŒ‰é’® ==========
const waitForTreeComplete = () => {
    composer.render(); 

    // åŸºç¡€æ¡ä»¶ï¼šç²’å­å½’ä½å®Œæˆ + ç²’å­åˆ›å»ºåè‡³å°‘1ç§’
    const isReady = ANIMATION_STATE.treeSettleComplete && (clock.getElapsedTime() * 1000 - ANIMATION_STATE.settleCheckTime > 1000);
    
    if (isReady) {
        // æ ¸å¿ƒä¿®æ”¹ï¼šé¢å¤–ç­‰å¾…0.5ç§’ï¼Œè®©è§†è§‰å®Œå…¨ç¨³å®š
        setTimeout(() => {
            const startBtn = document.getElementById('start-btn');
            if (startBtn) {
               startBtn.style.setProperty('display', 'block', 'important');
    startBtn.style.setProperty('pointer-events', 'auto', 'important');
    startBtn.style.setProperty('z-index', '99999', 'important');
            }
			// æ–°å¢ï¼šæ˜¾ç¤ºæ ‡é¢˜å’Œæ“ä½œè¯´æ˜
            document.getElementById('title').classList.add('show');
            document.getElementById('ui-layer2').classList.add('show');
            
            console.log('âœ… åœ£è¯æ ‘100%å®Œæ•´ï¼Œå¯åŠ¨æŒ‰é’®å·²æ˜¾ç¤ºï¼');
        }, 800); // 0.5ç§’å»¶è¿Ÿï¼Œç¡®ä¿ç”¨æˆ·è§†è§‰ä¸Šçœ‹åˆ°å®Œæ•´çš„æ ‘
        return;
    }

    requestAnimationFrame(waitForTreeComplete);
};

// ç²’å­åˆ›å»ºå®Œæˆåï¼Œå¯åŠ¨ç­‰å¾…æ£€æŸ¥
waitForTreeComplete();
			animate();
}
        // ==========================================
        // 4. Three.js æ ¸å¿ƒè®¾ç½®
        // ==========================================
        function initThree() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.colors.bg); // æ·±æµ·è“èƒŒæ™¯
            scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.012); 

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 0, CONFIG.camera.z); 

            renderer = new THREE.WebGLRenderer({ 
                antialias: false, // åæœŸå¤„ç†ä¼šè´Ÿè´£æŠ—é”¯é½¿
                powerPreference: "high-performance",
                stencil: false,
                depth: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.toneMapping = THREE.ACESFilmicToneMapping; 
            renderer.toneMappingExposure = 1.0; 
            container.appendChild(renderer.domElement);

            // åˆ†ç»„ç®¡ç†ï¼šèƒŒæ™¯ç»„ã€ä¸»ç‰©ä½“ç»„ã€ç…§ç‰‡ç»„
            bgGroup = new THREE.Group();
            scene.add(bgGroup);

            mainGroup = new THREE.Group();
            mainGroup.rotation.x = 0.1; // åˆå§‹è½»å¾®å€¾æ–œ
            scene.add(mainGroup);

            starGroup = new THREE.Group();
            mainGroup.add(starGroup);
            
            photoMeshGroup = new THREE.Group();
            mainGroup.add(photoMeshGroup);
        }

        function setupEnvironment() {
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            pmremGenerator.compileEquirectangularShader();
            scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.01).texture;
        }

        function setupLights() {
            const ambient = new THREE.AmbientLight(0xffffff, 0.2);
            scene.add(ambient);

            // åº•éƒ¨ç¯å…‰ï¼šæµ…å†°è“
            const bottomLight = new THREE.PointLight(CONFIG.colors.gold, 3, 40);
            bottomLight.position.set(0, -10, 10);
            mainGroup.add(bottomLight);

            // èšå…‰ç¯1ï¼šå†°é’è‰²
            const spotGold = new THREE.SpotLight(0xaaffff, 800);
            spotGold.position.set(40, 60, 40);
            spotGold.angle = 0.4;
            spotGold.penumbra = 0.5;
            spotGold.decay = 2;
            scene.add(spotGold);

            // èšå…‰ç¯2ï¼šæ·±æµ·è“
            const spotBlue = new THREE.SpotLight(0x004488, 400);
            spotBlue.position.set(-40, 10, -30);
            spotBlue.lookAt(0,0,0);
            scene.add(spotBlue);
        }

        function setupPostProcessing() {
            const renderScene = new RenderPass(scene, camera);
            // è¾‰å…‰æ•ˆæœï¼šé˜ˆå€¼ã€å¼ºåº¦ã€åŠå¾„
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.7; 
            bloomPass.strength = 0.4; 
            bloomPass.radius = 0.4;
            
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
        }

        // ==========================================
        // 5. ç²’å­ä¸å†…å®¹åˆ›å»º
        // ==========================================
        
        // ç²’å­ç±»ï¼šå°è£…æ¯ä¸ªç²’å­çš„è¡Œä¸ºé€»è¾‘
        class Particle {
            constructor(mesh, type, isDust = false) {
                this.mesh = mesh;
                this.type = type;
                this.isDust = isDust;
                
                this.posTree = new THREE.Vector3();    // æ ‘å½¢æ€çš„ç›®æ ‡ä½ç½®
                this.posScatter = new THREE.Vector3(); // æ•£å¼€å½¢æ€çš„ç›®æ ‡ä½ç½®
                
                // åŠ¨ç”»å±æ€§
                this.baseScale = mesh.scale.x; 
                this.offset = Math.random() * 100; // éšæœºç›¸ä½åç§»
                this.speed = 0.5 + Math.random();  // æ‘†åŠ¨é€Ÿåº¦
                
                // æè´¨è‡ªå‘å…‰å¤‡ä»½
                if (mesh.material && mesh.material.emissive) {
                    this.baseEmissive = mesh.material.emissive.clone();
                    this.hasEmissive = true;
                }
                
                this.calculatePositions(); // è®¡ç®—åˆå§‹å½¢æ€ä½ç½®
            }

            // è®¡ç®—è¯¥ç²’å­åœ¨ä¸åŒå½¢æ€ä¸‹çš„ä½ç½®
            calculatePositions() {
                const h = CONFIG.particles.treeHeight;
                let t = Math.random(); // é«˜åº¦æ¯”ä¾‹ 0~1
                
                // --- 1. è®¡ç®—æ ‘å½¢æ€åæ ‡ (Spiral Cone) ---
                if (Math.random() > 0.7 && !this.isDust && this.type !== 'PHOTO') {
                    // æ ¸å¿ƒæ ‘å¹²éƒ¨åˆ† (æ›´è§„åˆ™)
                    const y = (t * h) - h/2;
                    const rBase = CONFIG.particles.treeRadius * (1.0 - t);
                    const angle = t * Math.PI * 2 * 6; // èºæ—‹åœˆæ•°
                    this.posTree.set(Math.cos(angle) * rBase, y, Math.sin(angle) * rBase);
                } else {
                    // æ ‘å† å¡«å……éƒ¨åˆ† (æ›´éšæœº)
                    t = Math.pow(t, 0.8); // åˆ†å¸ƒæ›²çº¿è°ƒæ•´
                    const y = (t * h) - h/2;
                    let rMax = CONFIG.particles.treeRadius * (1.0 - t); 
                    if (rMax < 0.5) rMax = 0.5;
                    const angle = Math.random() * Math.PI * 2;
                    const r = rMax * Math.sqrt(Math.random()); 
                    this.posTree.set(Math.cos(angle) * r, y, Math.sin(angle) * r);
                }

                // --- 2. è®¡ç®—æ•£å¼€å½¢æ€åæ ‡ (Sphere Cloud) ---
                let rScatter = this.isDust ? (15 + Math.random()*25) : (10 + Math.random()*15);
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                this.posScatter.set(
                    rScatter * Math.sin(phi) * Math.cos(theta), 
                    rScatter * Math.sin(phi) * Math.sin(theta), 
                    rScatter * Math.cos(phi)
                );
            }

            update(dt, time, mode, focusTargetMesh) {
    let target = this.posTree;
    let s = this.baseScale;
    // æ ¸å¿ƒï¼šæœªå¯åŠ¨åœºæ™¯æ—¶ï¼Œç”¨æœ€å¿«é€Ÿåº¦æ’å€¼ï¼ˆlerpSpeed=10ï¼‰
    let lerpSpeed = window.isSceneStarted ? 3.0 : 15.0; 

    // æœªå¯åŠ¨åœºæ™¯æ—¶ï¼Œå¼ºåˆ¶æ ‘æ¨¡å¼ï¼Œå¿½ç•¥å…¶ä»–æ¨¡å¼
    if (!window.isSceneStarted) {
        mode = 'TREE';
    }

    // åŸæœ‰æ¨¡å¼é€»è¾‘ä¿ç•™ï¼ˆå¯åŠ¨åç”Ÿæ•ˆï¼‰
    if (mode === 'SCATTER') {
        target = this.posScatter;
    } 
    else if (mode === 'FOCUS') {
        if (this.mesh === focusTargetMesh) {
            const invMatrix = new THREE.Matrix4().copy(mainGroup.matrixWorld).invert();
            const camPos = new THREE.Vector3(0, 0, CONFIG.camera.z - 15);
            target = camPos.applyMatrix4(invMatrix);
            lerpSpeed = 6.0;
            this.mesh.lookAt(camera.position);
            s = this.baseScale * 5.0;
        } else {
            target = this.posScatter;
            s = 0.01;
        }
    } 
    else if (mode === 'METEOR') {
        target = this.posScatter; 
        if (!this.isDust) s = 0;
    }

    // æœªå¯åŠ¨åœºæ™¯æ—¶ï¼Œå…³é—­å™ªå£°ï¼ˆé¿å…ç²’å­æ¥å›æ™ƒï¼Œå¡ä½ä¸åŠ¨ï¼‰
    const dest = target.clone();
    if(mode === 'TREE' && window.isSceneStarted) { 
        const noiseY = Math.sin(time * this.speed + this.offset) * 0.15;
        const noiseX = Math.cos(time * 0.5 * this.speed + this.offset) * 0.1;
        dest.y += noiseY; dest.x += noiseX; 
    }

    // ä½ç½®æ’å€¼ï¼ˆæœªå¯åŠ¨æ—¶é€Ÿåº¦Ã—10ï¼Œå¿«é€Ÿå½’ä½ï¼‰
    this.mesh.position.lerp(dest, lerpSpeed * dt);

    // é—ªçƒæ•ˆæœï¼ˆæœªå¯åŠ¨æ—¶å…³é—­ï¼Œé¿å…å¹²æ‰°ï¼‰
    if (this.hasEmissive && mode === 'TREE' && !this.isDust && window.isSceneStarted) {
        const blink = Math.sin(time * 2 + this.offset);
        this.mesh.material.emissiveIntensity = blink > 0.5 ? (1.0 + (blink - 0.5) * 4) : 0.3;
    }

    // ç¼©æ”¾å¤„ç†ï¼ˆæœªå¯åŠ¨æ—¶å›ºå®šå°ºå¯¸ï¼Œä¸æ™ƒï¼‰
    if (mode !== 'FOCUS') {
         if (this.isDust && window.isSceneStarted) {
            s = this.baseScale * (0.5 + 0.5 * Math.sin(time * 3 + this.offset));
        } else if (mode === 'SCATTER' && this.type === 'PHOTO') {
            s = this.baseScale * 2.5;
        }
    }
    
    this.mesh.scale.lerp(new THREE.Vector3(s,s,s), window.isSceneStarted ? 5*dt : 10*dt);
}
		}

        // åˆ›å»ºç¨‹åºåŒ–çº¹ç† (Candy Cane)
        function createTextures() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,128,128);
            ctx.fillStyle = '#002244'; // æ·±æµ·è“ï¼ˆæ›¿æ¢åŸ#cc2200ï¼‰
            ctx.beginPath();
            for(let i=-128; i<256; i+=32) {
                ctx.moveTo(i, 0); ctx.lineTo(i+32, 128); ctx.lineTo(i+16, 128); ctx.lineTo(i-16, 0);
            }
            ctx.fill();
            caneTexture = new THREE.CanvasTexture(canvas);
            caneTexture.colorSpace = THREE.SRGBColorSpace;
            caneTexture.wrapS = THREE.RepeatWrapping; caneTexture.wrapT = THREE.RepeatWrapping;
            caneTexture.repeat.set(3, 3);
        }
		// âœ… æ–°å¢ï¼šé›ªèŠ±æè´¨åº“ + å…¨å±€é›ªèŠ±ç³»ç»Ÿå˜é‡
const matLib = {
    snowFlake: new THREE.PointsMaterial({
        color: 0xffffff,          // é›ªèŠ±ç™½è‰²
        size: 0.8,                // é›ªèŠ±åŸºç¡€å¤§å°
        transparent: false,        // å¼€å¯é€æ˜
        opacity: 0.9,             // é›ªèŠ±é€æ˜åº¦
        blending: THREE.AdditiveBlending, // å åŠ æ··åˆï¼ˆæ›´é€šé€ï¼‰
        depthWrite: false,        // è§£å†³é€æ˜ç²’å­æ¸²æŸ“å±‚çº§é—®é¢˜
        sizeAttenuation: true,    // è¿œè¿‘å¤§å°è¡°å‡ï¼ˆçœŸå®æ„Ÿï¼‰
		alphaMap: createCircleTexture(), // è‡ªå®šä¹‰åœ†å½¢çº¹ç†
        alphaTest: 0.5 // å‰”é™¤é€æ˜éƒ¨åˆ†ï¼Œåªæ˜¾ç¤ºåœ†å½¢
    })
};
let snowSystem; // å…¨å±€é›ªèŠ±ç²’å­ç³»ç»Ÿå¼•ç”¨
		// è¾…åŠ©å‡½æ•°ï¼šç”Ÿæˆåœ†å½¢çº¹ç†ï¼ˆæ— éœ€å¤–éƒ¨å›¾ç‰‡ï¼‰
function createCircleTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 64;
    canvas.height = 64;
    const ctx = canvas.getContext('2d');
    // ç”»åœ†å½¢
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(32, 32, 30, 0, Math.PI * 2);
    ctx.fill();
    // è½¬ä¸ºThree.jsçº¹ç†
    const texture = new THREE.CanvasTexture(canvas);
    return texture;
}
        // åˆ›å»ºèƒŒæ™¯é“¶æ²³ç²’å­
        function createGalaxyBackground() {
            const geometry = new THREE.BufferGeometry();
            const count = 3000;
            const positions = new Float32Array(count * 3);
            const sizes = new Float32Array(count);
            const colors = new Float32Array(count * 3);
            const c1 = new THREE.Color(0xaaffff);  // æµ…å†°è“
            const c2 = new THREE.Color(0x00ffff);  // å†°é’è‰²
            const c3 = new THREE.Color(0x002244);  // æ·±æµ·è“ 

            for(let i=0; i<count; i++) {
                const r = 60 + Math.random() * 250;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                positions[i*3] = r * Math.sin(phi) * Math.cos(theta);
                positions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
                positions[i*3+2] = r * Math.cos(phi);
                sizes[i] = Math.random() * 2.0;
                let c = Math.random(); let finalC = c < 0.6 ? c2 : (c < 0.9 ? c1 : c3);
                colors[i*3] = finalC.r; colors[i*3+1] = finalC.g; colors[i*3+2] = finalC.b;
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 1.0, transparent: true, opacity: 0.8, vertexColors: true,
                sizeAttenuation: true, blending: THREE.AdditiveBlending, depthWrite: false
            });
            bgGroup.add(new THREE.Points(geometry, material));
        }

		// âœ… æ–°å¢ï¼šåˆ›å»ºä¸‹é›ªèƒŒæ™¯ç²’å­ç³»ç»Ÿ
function createSnowBackground() {
    try {
        // 1. ç¡®è®¤å‡½æ•°è¢«è°ƒç”¨ + æ‰“å°CONFIGé…ç½®ï¼ˆæ ¸å¿ƒæ’æŸ¥ï¼‰
        console.log('===== å¼€å§‹åˆ›å»ºé›ªèŠ±ç³»ç»Ÿ =====');
        console.log('CONFIGæ˜¯å¦å­˜åœ¨:', typeof CONFIG !== 'undefined' ? 'âœ… å­˜åœ¨' : 'âŒ ä¸å­˜åœ¨');
        console.log('CONFIG.particles:', CONFIG?.particles);
        console.log('é›ªèŠ±æ•°é‡é…ç½® snowCount:', CONFIG?.particles?.snowCount);

        // 2. å…œåº•å¤„ç†ï¼šå¦‚æœCONFIGæœªå®šä¹‰/å€¼å¼‚å¸¸ï¼Œå¼ºåˆ¶è®¾ä¸º2500
        const count = CONFIG?.particles?.snowCount || 2500;
        console.log('æœ€ç»ˆä½¿ç”¨çš„é›ªèŠ±æ•°é‡:', count);

        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(count * 3);
        const velocities = new Float32Array(count); // æ¯ä¸ªé›ªèŠ±çš„ä¸‹è½é€Ÿåº¦
        const sizes = new Float32Array(count);      // æ¯ä¸ªé›ªèŠ±çš„å¤§å°

        // 3. åˆå§‹åŒ–é›ªèŠ±æ•°æ®æ—¶æ‰“å°è¿›åº¦ï¼ˆéªŒè¯å¾ªç¯æ‰§è¡Œï¼‰
        console.log('å¼€å§‹åˆå§‹åŒ–é›ªèŠ±ä½ç½®/é€Ÿåº¦/å¤§å°...');
        for (let i = 0; i < count; i++) {
            positions[i * 3] = (Math.random() - 0.5) * window.innerWidth;  // Xè½´ï¼š-100 ~ 100
            positions[i * 3 + 1] = (Math.random() * 100) + 50; // Yè½´ï¼š50 ~ 150ï¼ˆä»é¡¶éƒ¨å¼€å§‹ï¼‰
            positions[i * 3 + 2] = -50+(Math.random() - 0.5) * 100; // Zè½´ï¼š-75 ~ 75
            
            velocities[i] = 1.0 + Math.random() * 2; // ä¸‹è½é€Ÿåº¦ï¼š1 ~ 3
            sizes[i] = 0.5 + Math.random() * 1.5;    // é›ªèŠ±å¤§å°ï¼š0.5 ~ 2

            // 4. æ‰“å°å‰3ä¸ªé›ªèŠ±çš„åˆå§‹åŒ–æ•°æ®ï¼ˆéªŒè¯æ•°æ®æ˜¯å¦æ­£å¸¸ï¼‰
            if (i < 3) {
                console.log(`é›ªèŠ±${i}åˆå§‹åŒ–æ•°æ®:`, {
                    position: [positions[i*3], positions[i*3+1], positions[i*3+2]],
                    velocity: velocities[i],
                    size: sizes[i]
                });
            }
        }

        // 5. ç»‘å®šå‡ ä½•ä½“å±æ€§åæ‰“å°å‡ ä½•ä½“ä¿¡æ¯
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 1));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
        console.log('é›ªèŠ±å‡ ä½•ä½“åˆ›å»ºå®Œæˆ:', geometry);
        console.log('å‡ ä½•ä½“é¡¶ç‚¹æ•°é‡:', geometry.attributes.position.count);

        // 6. åˆ›å»ºé›ªèŠ±ç²’å­ç³»ç»Ÿå¹¶éªŒè¯
        console.log('é›ªèŠ±æè´¨ matLib.snowFlake:', matLib?.snowFlake);
        snowSystem = new THREE.Points(geometry, matLib.snowFlake);
        snowSystem.visible = true; // é»˜è®¤å¼€å¯ä¸‹é›ª
        console.log('é›ªèŠ±ç²’å­ç³»ç»Ÿåˆ›å»ºå®Œæˆ:', snowSystem);
        console.log('é›ªèŠ±ç³»ç»Ÿæ˜¯å¦å¯è§:', snowSystem.visible);

        // 7. éªŒè¯bgGroupå¹¶æ·»åŠ ï¼Œæ‰“å°ç»“æœ
        console.log('èƒŒæ™¯ç»„ bgGroup æ˜¯å¦å­˜åœ¨:', typeof bgGroup !== 'undefined' ? 'âœ… å­˜åœ¨' : 'âŒ ä¸å­˜åœ¨');
        if (bgGroup) {
            bgGroup.add(snowSystem);
            console.log('âœ… é›ªèŠ±ç³»ç»Ÿå·²æˆåŠŸæ·»åŠ åˆ°bgGroupï¼');
            console.log('bgGroupå­å…ƒç´ æ•°é‡:', bgGroup.children.length);
        } else {
            console.error('âŒ æ— æ³•æ·»åŠ é›ªèŠ±åˆ°bgGroupï¼šbgGroupæœªå®šä¹‰ï¼');
        }

        console.log('===== é›ªèŠ±ç³»ç»Ÿåˆ›å»ºæµç¨‹ç»“æŸ =====');
    } catch (error) {
        // 8. æ•è·æ‰€æœ‰é”™è¯¯ï¼Œé¿å…å‡½æ•°å´©æºƒï¼ŒåŒæ—¶æ‰“å°è¯¦ç»†é”™è¯¯ä¿¡æ¯
        console.error('âŒ åˆ›å»ºé›ªèŠ±ç³»ç»Ÿæ—¶å‘ç”Ÿé”™è¯¯ï¼š', error);
        console.error('é”™è¯¯ä½ç½®:', error.stack);
    }
}

        // åˆ›å»ºä¸»ç²’å­ç³»ç»Ÿ
        function createParticles() {
    // è¿”å›Promiseï¼Œè®©init()èƒ½ç­‰å¾…ç²’å­å…¨éƒ¨åˆ›å»ºå®Œæˆ
    return new Promise((resolve) => {
        const sphereGeo = new THREE.SphereGeometry(0.5, 32, 32); 
        const boxGeo = new THREE.BoxGeometry(0.45, 0.45, 0.45); 
        // ç³–æœå½¢çŠ¶
        const curve = new THREE.CatmullRomCurve3([new THREE.Vector3(0, -0.5, 0), new THREE.Vector3(0, 0.3, 0), new THREE.Vector3(0.1, 0.5, 0), new THREE.Vector3(0.3, 0.4, 0)]);
        const candyGeo = new THREE.TubeGeometry(curve, 16, 0.08, 8, false);

        // å†°è“ç³»æè´¨åº“
        const goldMat = new THREE.MeshStandardMaterial({ 
            color: CONFIG.colors.gold, // æµ…å†°è“
            metalness: 1.0, 
            roughness: 0.15, 
            envMapIntensity: 2.5, 
            emissive: 0x004488, // æ·±æµ·è“è‡ªå‘å…‰
            emissiveIntensity: 0.4 
        });
        const greenMat = new THREE.MeshStandardMaterial({ 
            color: CONFIG.colors.green, // æµ…è“ç»¿
            metalness: 0.4, 
            roughness: 0.3, 
            emissive: 0x002244, // æ·±æµ·è“è‡ªå‘å…‰
            emissiveIntensity: 0.2 
        });
        const redMat = new THREE.MeshPhysicalMaterial({ 
            color: CONFIG.colors.red, // å†°é’è‰²
            metalness: 0.6, 
            roughness: 0.2, 
            clearcoat: 1.0, 
            emissive: 0x0088aa, // æµ…è“ç»¿è‡ªå‘å…‰
            emissiveIntensity: 0.6 
        });
        const candyMat = new THREE.MeshStandardMaterial({ 
            map: caneTexture, 
            roughness: 0.3, 
            metalness: 0.1, 
            emissive: 0x002244 // æ·±æµ·è“è‡ªå‘å…‰
        });
        
        const dustGeo = new THREE.OctahedronGeometry(0.1, 0);
        const dustMat = new THREE.MeshBasicMaterial({ 
            color: CONFIG.colors.gold, // æµ…å†°è“
            blending: THREE.AdditiveBlending 
        });

        // 1. ç”Ÿæˆä¸»ä½“è£…é¥°
        for (let i = 0; i < CONFIG.particles.count; i++) {
            const rand = Math.random(); 
            let mesh, type;
            if (rand < 0.35) { mesh = new THREE.Mesh(boxGeo, greenMat); type = 'BOX'; } 
            else if (rand < 0.70) { mesh = new THREE.Mesh(boxGeo, goldMat); type = 'GOLD_BOX'; } 
            else if (rand < 0.90) { mesh = new THREE.Mesh(sphereGeo, goldMat); type = 'GOLD_SPHERE'; } 
            else if (rand < 0.96) { mesh = new THREE.Mesh(sphereGeo, redMat); type = 'RED'; } 
            else { mesh = new THREE.Mesh(candyGeo, candyMat); type = 'CANE'; }
            
            const s = 0.4 + Math.random() * 0.4;
            mesh.scale.set(s,s,s);
            mesh.rotation.set(Math.random()*6, Math.random()*6, Math.random()*6);
            mainGroup.add(mesh);
            particleSystem.push(new Particle(mesh, type, false));
        }

        // 2. ç”Ÿæˆæ˜Ÿå°˜
        for(let i=0; i<CONFIG.particles.dustCount; i++) {
            const mesh = new THREE.Mesh(dustGeo, dustMat);
            mesh.scale.setScalar(0.5 + Math.random());
            mainGroup.add(mesh);
            particleSystem.push(new Particle(mesh, 'DUST', true));
        }

        // 3. æ ‘é¡¶æ˜Ÿæ˜Ÿï¼ˆç¡®ä¿æ˜Ÿæ˜Ÿä¹Ÿåˆ›å»ºå®Œæˆï¼‰
        createStarTopper();

        // ========== å…³é”®ï¼šç­‰å¾…ç²’å­æ•°æ®ä¸Šä¼ GPUåï¼Œæ ‡è®°åˆ›å»ºå®Œæˆ ==========
        // 200mså»¶è¿Ÿï¼šç»™Three.jsæ—¶é—´æŠŠç²’å­å‡ ä½•ä½“/æè´¨ä¸Šä¼ åˆ°GPUï¼ˆæ¸²æŸ“å‰çš„å…³é”®æ­¥éª¤ï¼‰
        setTimeout(() => {
            console.log(`åœ£è¯æ ‘ç²’å­åˆ›å»ºå®Œæˆï¼šä¸»ä½“è£…é¥°${CONFIG.particles.count}ä¸ª + æ˜Ÿå°˜${CONFIG.particles.dustCount}ä¸ª + æ ‘é¡¶æ˜Ÿæ˜Ÿ`);
            resolve(true); // å‘Šè¯‰init()ï¼šç²’å­å…¨éƒ¨åˆ›å»ºå¥½äº†
        }, 1000);
    });
}
        function createStarTopper() {
            const starGeo = new THREE.OctahedronGeometry(1.5, 0);
            const starMat = new THREE.MeshStandardMaterial({ 
                color: 0xaaffff, // æµ…å†°è“
                emissive: 0x00ffff, // å†°é’è‰²è‡ªå‘å…‰
                emissiveIntensity: 2.5, 
                metalness: 1.0, 
                roughness: 0 
            });
            const star = new THREE.Mesh(starGeo, starMat);
            star.position.set(0, CONFIG.particles.treeHeight/2 + 1.2, 0);
            
            // ç®€å•å…‰æ™• Sprite
            const halo = new THREE.Mesh(new THREE.PlaneGeometry(8, 8), new THREE.MeshBasicMaterial({ 
                map: new THREE.TextureLoader().load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/sprites/glow.png'), 
                blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, opacity: 0.5, color: 0xff4500
            }));
            star.add(halo);
            starGroup.add(star);
            STATE.starMesh = star;
        }

        // ==========================================
        // 6. ç…§ç‰‡ä¸Šä¼ ä¸å¤„ç†
        // ==========================================
function addTipPhotoAsParticles(texture) {
    // 1. å®¹é”™ï¼šçº¹ç†/çº¹ç†å›¾ç‰‡ä¸å­˜åœ¨åˆ™è¿”å›ï¼ˆå’Œ addPhotoToScene ä¸€è‡´ï¼‰
    const img = texture.image;
    if (!img || !texture) return;

    // 2. ç²’å­åŸºç¡€é…ç½®ï¼ˆå¯è‡ªå®šä¹‰ï¼‰
    const particleCount = 50;  // æ¯å¼ å›¾ç‰‡ç”Ÿæˆ100ä¸ªç²’å­
    const cylinderRadius = 0.3; // åœ†æŸ±åŠå¾„
    const cylinderHeight = 0.2; // åœ†æŸ±é«˜åº¦ï¼ˆçŸ­åœ†æŸ±ï¼‰
    const scaleFactor = 4;      // ç²’å­ç¼©æ”¾ç³»æ•°

    // 3. å¾ªç¯ç”Ÿæˆç²’å­ï¼ˆæ ¸å¿ƒé€»è¾‘ï¼‰
    for (let i = 0; i < particleCount; i++) {
        // 3.1 åˆ›å»ºçŸ­åœ†æŸ±å‡ ä½•ä½“ï¼ˆä½ çš„åŸé…ç½®ï¼‰
        const geometry = new THREE.CylinderGeometry(
            cylinderRadius,  // é¡¶éƒ¨åŠå¾„
            cylinderRadius,  // åº•éƒ¨åŠå¾„
            cylinderHeight,  // é«˜åº¦
            32               // åˆ†æ®µæ•°ï¼ˆè¶Šé«˜é“æŸ±è¶Šåœ†ï¼‰
        );

        // 3.2 åˆ›å»ºæè´¨ï¼ˆæ¨¡ä»¿ç›¸æ¡†çš„é‡‘å±è´¨æ„Ÿ + é€æ˜/çº¹ç†é…ç½®ï¼‰
        const material = new THREE.MeshStandardMaterial({
            map: texture,               // ç»‘å®šçš®å¤´ç…§ç‰‡çº¹ç†
            transparent: true,          // å¼€å¯é€æ˜ï¼ˆé¿å…é®æŒ¡ï¼‰
            depthWrite: false,          // è§£å†³é€æ˜æ¸²æŸ“å±‚çº§é—®é¢˜
            metalness: 0.7,             // æ¨¡ä»¿ç›¸æ¡†çš„é«˜é‡‘å±æ„Ÿï¼ˆåŸ0.9â†’1.0æ›´è´´è¿‘ï¼‰
            roughness: 0.4,             // ä½ç²—ç³™åº¦=é«˜å…‰æ³½ï¼ˆåŸ0.6â†’0.2æ›´è´´è¿‘ç›¸æ¡†ï¼‰
			flatShading: true,
            emissiveIntensity: 0.3     // å¾®å¼±è‡ªå‘å…‰
        });

        // 3.3 åˆ›å»ºåœ†æŸ±ç²’å­ç½‘æ ¼
        const particleMesh = new THREE.Mesh(geometry, material);

        // 3.4 ç²’å­ä½ç½®ï¼ˆæ¨¡ä»¿ç…§ç‰‡çš„å°ºå¯¸é€‚é…æ€è·¯ï¼Œé™å®šä½ç½®èŒƒå›´ï¼Œé¿å…å¤ªåˆ†æ•£ï¼‰
        // çš®å¤´ç²’å­ä¸“å±åŒºåŸŸï¼šXè½´ 5~10ï¼ŒY/Zè½´ -5~5ï¼ˆå’Œæ™®é€šç²’å­åŒºåˆ†ï¼‰
        particleMesh.position.set(
            Math.random() * 5 + 5,    // X: 5~10
            Math.random() * 10 - 5,   // Y: -5~5
            Math.random() * 10 - 5    // Z: -5~5
        );

        // 3.5 ç²’å­æ—‹è½¬ï¼ˆéšæœºè§’åº¦ï¼‰
        particleMesh.rotation.set(
            Math.random() * Math.PI,
            Math.random() * Math.PI,
            Math.random() * Math.PI
        );

        // 3.6 ç²’å­ç¼©æ”¾ï¼ˆæ¨¡ä»¿ç…§ç‰‡çš„å°ºå¯¸é™åˆ¶ï¼Œé¿å…è¿‡å¤§/è¿‡å°ï¼‰
        particleMesh.scale.set(
            Math.random() * scaleFactor + 1,
            Math.random() * scaleFactor + 1,
            Math.random() * scaleFactor + 1
        );

        // 3.7 é€æ˜åº¦ï¼ˆå›ºå®š1ï¼Œä¹Ÿå¯éšæœºï¼‰
        material.opacity = 1;

        // 4. åŠ å…¥åœºæ™¯ï¼ˆå’Œ addPhotoToScene çš„ photoMeshGroup é€»è¾‘ä¸€è‡´ï¼‰
        // å»ºè®®åˆ›å»ºä¸“å±çš„ç²’å­ç»„ï¼Œæ–¹ä¾¿ç®¡ç†ï¼ˆå’Œç…§ç‰‡ç»„åŒºåˆ†ï¼‰
        if (!window.tipParticleGroup) {
            window.tipParticleGroup = new THREE.Group(); // çš®å¤´ç²’å­æ€»å®¹å™¨
            mainGroup.add(window.tipParticleGroup);      // åŠ å…¥ä¸»åœºæ™¯
        }
        window.tipParticleGroup.add(particleMesh);

        // 5. åŠ å…¥ç²’å­ç³»ç»Ÿï¼ˆå’Œ addPhotoToScene ä¸€è‡´ï¼‰
        if (typeof particleSystem !== 'undefined' && typeof Particle === 'function') {
            particleSystem.push(new Particle(particleMesh, 'TIP_PARTICLE', false));
        }
    }

    // æ—¥å¿—ï¼šç²’å­ç”ŸæˆæˆåŠŸ
    console.log(`çš®å¤´ç…§ç‰‡ç²’å­ç”Ÿæˆå®Œæˆï¼å…±ç”Ÿæˆ ${particleCount} ä¸ªçŸ­åœ†æŸ±ç²’å­`);
}
	



        /**
 * æ·»åŠ ç…§ç‰‡åˆ°åœºæ™¯ï¼ˆé€‚é…æ™®é€š/å¥–åŠ±ç…§ç‰‡æ ‡è®°ï¼‰
 * @param {THREE.Texture} texture - ç…§ç‰‡çº¹ç†
 * @param {string} type - ç±»å‹ï¼šNORMAL/REWARDï¼ˆé»˜è®¤NORMALï¼‰
 * @param {number} probability - å¥–åŠ±æ¦‚ç‡ï¼ˆé»˜è®¤1ï¼‰
 */
function addPhotoToScene(texture, type = 'NORMAL', probability = 1) {
  const img = texture.image;
  if (!img) return;

  // åŸæœ‰é€»è¾‘ï¼šè®¡ç®—å®½é«˜æ¯”+åˆ›å»ºç›¸æ¡†/ç…§ç‰‡ï¼ˆå®Œå…¨ä¿ç•™ï¼‰
  const aspect = img.width / img.height;   
  const maxSize = 1.2;                     
  let photoW, photoH;
  if (aspect >= 1) { photoW = maxSize; photoH = maxSize / aspect; } 
  else { photoH = maxSize; photoW = maxSize * aspect; }

  const frameMargin = 0.15;                
  const group = new THREE.Group();

  const frameGeo = new THREE.BoxGeometry(photoW + frameMargin, photoH + frameMargin, 0.1);
  const frameMat = new THREE.MeshStandardMaterial({ 
      color: CONFIG.colors.gold, // æµ…å†°è“
      metalness: 1.0, 
      roughness: 0.2 
  });
  const frame = new THREE.Mesh(frameGeo, frameMat);

  const photoGeo = new THREE.PlaneGeometry(photoW, photoH);
  const photoMat = new THREE.MeshStandardMaterial({ // æ›¿æ¢MeshBasicMaterial
    map: texture });
  const photo = new THREE.Mesh(photoGeo, photoMat);
  photo.position.z = 0.06;

  group.add(frame);
  group.add(photo);
  photoMeshGroup.add(group);
	

 // ========== å…³é”®ä¿®æ”¹ï¼šç»‘å®šå›¾ç‰‡åç§°+å¼ºåŒ–ç±»å‹/æ¦‚ç‡æ ‡è®° ==========
  // 1. è·å–å›¾ç‰‡æ–‡ä»¶åï¼ˆå¦‚reward1.jpgï¼Œç”¨äºæ’æŸ¥ï¼‰
  const imgName = texture.image.src.split('/').pop();
  // 2. ç»™ç…§ç‰‡Groupç»‘å®šå®Œæ•´å…ƒä¿¡æ¯ï¼ˆåŒ…å«åç§°ï¼‰
  group.userData = { 
    type: type,          // æ˜ç¡®æ ‡è®°ç±»å‹ï¼šNORMAL/REWARD
    probability: probability, // æ˜ç¡®æ ‡è®°æ¦‚ç‡
    name: imgName        // æ–°å¢ï¼šç»‘å®šå›¾ç‰‡åç§°ï¼Œæ–¹ä¾¿æ§åˆ¶å°æ’æŸ¥
  };
  // 3. åŒæ­¥åˆ°å…¨å±€photosæ•°ç»„ï¼ˆç¡®ä¿ç±»å‹/æ¦‚ç‡/åç§°ä¸€ä¸€å¯¹åº”ï¼‰
  window.photos.push({ 
    mesh: group, 
    type: type,          // æ˜¾å¼èµ‹å€¼ï¼Œé¿å…éšå¼ç±»å‹é”™è¯¯
    probability: probability, // æ˜¾å¼èµ‹å€¼ï¼Œç¡®ä¿æ¦‚ç‡å‡†ç¡®
    name: imgName        // æ–°å¢ï¼šä¿å­˜å›¾ç‰‡åç§°ï¼Œæ’æŸ¥æ—¶èƒ½çœ‹åˆ°æ˜¯å“ªå¼ å›¾
  });

  // åŸæœ‰é€»è¾‘ï¼šåŠ å…¥ç²’å­ç³»ç»Ÿ
  particleSystem.push(new Particle(group, 'PHOTO', false));

  // æ–°å¢ï¼šæ§åˆ¶å°æ—¥å¿—ï¼ˆæ–¹ä¾¿éªŒè¯åŠ è½½æ˜¯å¦æ­£ç¡®ï¼‰
  console.log(`[æ·»åŠ ç…§ç‰‡] åç§°=${imgName}ï¼Œç±»å‹=${type}ï¼Œæ¦‚ç‡=${probability}ï¼Œç´¢å¼•=${window.photos.length-1}`);
}
     




        // ==========================================
        // 7. MediaPipe æ‰‹åŠ¿è¯†åˆ«é€»è¾‘
        // ==========================================
        async function initMediaPipe() {
    const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
    handLandmarker = await HandLandmarker.createFromOptions(vision, {
        baseOptions: { 
            modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, 
            delegate: "GPU" 
        },
        runningMode: "VIDEO", numHands: 1
    });
    
    video = document.getElementById('webcam');
    const canvasElement = document.getElementById('webcam-preview');
    canvasCtx = canvasElement.getContext('2d');
    drawingUtils = new DrawingUtils(canvasCtx);
    
    if (navigator.mediaDevices?.getUserMedia) {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { facingMode: "user", width: { ideal: 640 }, height: { ideal: 480 } } 
            });
            video.srcObject = stream;
            
            video.addEventListener("loadeddata", () => { 
                video.play(); 
                
                // === ã€å½»åº•åˆ é™¤ã€‘æ‰€æœ‰æ§åˆ¶wrapperå°ºå¯¸çš„ä»£ç  ===
                // åªä¿ç•™Canvasé˜²æ¨¡ç³Šçš„è®¾ç½®ï¼ˆä¸å½±å“æ˜¾ç¤ºå°ºå¯¸ï¼‰
                const videoW = video.videoWidth;
                const videoH = video.videoHeight;
                canvasElement.width = videoW;
                canvasElement.height = videoH;
                // ============================================

                const wrapper = document.getElementById('webcam-wrapper');
                wrapper.style.opacity = 1; // åªæ§åˆ¶æ˜¾éšï¼Œä¸æ§åˆ¶å°ºå¯¸
                predictWebcam(); 
            });
        } catch (e) { console.warn("æ‘„åƒå¤´è®¿é—®è¢«æ‹’ç»", e); }
    }
}

// predictWebcamå‡½æ•°ä¿æŒä¸å˜ï¼ˆæ— éœ€ä¿®æ”¹ï¼‰
let lastVideoTime = -1;
async function predictWebcam() {
    const canvasElement = document.getElementById('webcam-preview');
    if (video.videoWidth && canvasElement.width !== video.videoWidth) { 
        canvasElement.width = video.videoWidth; canvasElement.height = video.videoHeight; 
    }
    
    if (lastVideoTime !== video.currentTime) {
        lastVideoTime = video.currentTime;
        let result = null;
        if (handLandmarker) result = handLandmarker.detectForVideo(video, performance.now());
        
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        canvasCtx.drawImage(video, 0, 0, canvasElement.width, canvasElement.height);
        
        if (result && result.landmarks && result.landmarks.length > 0) {
            for (const landmarks of result.landmarks) {
                drawingUtils.drawConnectors(landmarks, HandLandmarker.HAND_CONNECTIONS, { color: "#d4af37", lineWidth: 3 });
                drawingUtils.drawLandmarks(landmarks, { color: "#ffffff", lineWidth: 1, radius: 3 });
            }
            processGestures(result.landmarks[0]);
        } else { 
            STATE.hand.detected = false; 
        }
        canvasCtx.restore();
    }
    requestAnimationFrame(predictWebcam);
}

        // æ ¸å¿ƒæ‰‹åŠ¿åˆ¤æ–­ç®—æ³•
       // æ ¸å¿ƒæ‰‹åŠ¿åˆ¤æ–­ç®—æ³•ï¼ˆç»ˆæä¿®å¤ï¼šPinchå¾ªç¯åˆ‡æ¢ç…§ç‰‡ï¼‰
function processGestures(lm) {
	 // æ ¸å¿ƒï¼šæœªå¯åŠ¨åœºæ™¯ æˆ– æ‘„åƒå¤´æœªåˆå§‹åŒ– â†’ ç¦ç”¨æ‰‹åŠ¿
    if (!window.isSceneStarted || !window.mediaPipeInited) return;
    STATE.hand.detected = true;

	if (window.isRewardFrozen) return;

    // ========== 1. æå‰åˆå§‹åŒ–ç´¢å¼•ï¼ˆåªåˆå§‹åŒ–ä¸€æ¬¡ï¼Œæ°¸ä¸é‡ç½®ï¼‰ ==========
    if (typeof window.photoIndex === 'undefined') {
        window.photoIndex = 0; // ç”¨windowå…¨å±€å˜é‡ï¼Œé¿å…STATEè¢«æ„å¤–é‡ç½®
    }

    // è·å–å…³é”®ç‚¹åæ ‡ (0:æ‰‹è…•, 4:æ‹‡æŒ‡å°–, 8:é£ŸæŒ‡å°–, 9:æŒå¿ƒ, 12:ä¸­æŒ‡å°–, 16:æ— åæŒ‡å°–, 20:å°æŒ‡å°–)
    const wrist = lm[0];
    const thumbTip = lm[4];
    const indexTip = lm[8];
    const middleTip = lm[12];
    const ringTip = lm[16];
    const pinkyTip = lm[20];
    const palm = lm[9]; 

    // ========== 2. Pinchæ‰‹åŠ¿åˆ¤å®šï¼ˆæ‹‡æŒ‡+é£ŸæŒ‡æåˆï¼‰ ==========
    const pinchDistance = Math.hypot(
        thumbTip.x - indexTip.x, 
        thumbTip.y - indexTip.y,
        thumbTip.z - indexTip.z
    );
    const pinchThreshold = 0.05;
    const isPinching = pinchDistance < pinchThreshold;
    
    // è®°å½•ä¸Šä¸€å¸§PinchçŠ¶æ€ï¼ˆå…¨å±€å˜é‡ï¼Œé¿å…ä¸¢å¤±ï¼‰
    if (typeof window.lastPinch === 'undefined') window.lastPinch = false;
    const isJustPinched = !window.lastPinch && isPinching;

	// ========== âœ… æ–°å¢ï¼šGA4ç»Ÿè®¡ã€Œæåˆæ‰‹åŠ¿å°è¯•ã€äº‹ä»¶ ==========
    if (isJustPinched && window.gtag) { // ä»…ã€Œé¦–æ¬¡æåˆã€æ—¶ç»Ÿè®¡ï¼Œé¿å…é‡å¤è®¡æ•°
        gtag('event', 'gesture_pinch', {
            event_category: 'æ‰‹åŠ¿äº¤äº’', // äº‹ä»¶åˆ†ç±»ï¼ˆæ–¹ä¾¿ç­›é€‰ï¼‰
            event_label: 'ç”¨æˆ·å°è¯•æåˆæ‰‹åŠ¿ï¼ˆPinchï¼‰', // äº‹ä»¶æè¿°
            value: 1, // è®¡æ•°ç”¨ï¼Œå›ºå®šä¼ 1
            // å¯é€‰ï¼šæ–°å¢ç»´åº¦ï¼ŒåŒºåˆ†æåˆæ˜¯å¦æˆåŠŸæŠ“åˆ°å†…å®¹
            pinch_attempt_type: window.photos?.length > 0 ? 'å°è¯•æŠ“ç…§ç‰‡' : 'æ— ç…§ç‰‡ï¼ˆæŠ“æ˜Ÿæ˜Ÿï¼‰'
        });
        console.log('ğŸ“Š GA4ï¼šç”¨æˆ·å°è¯•æåˆæ‰‹åŠ¿ï¼Œå·²ä¸ŠæŠ¥gesture_pinchäº‹ä»¶');
    }
    // ========== GA4ç»Ÿè®¡ä»£ç ç»“æŸ ==========

    // ========== 3. æ‰‹æŒå¼ å¼€ç¨‹åº¦åˆ¤å®šï¼ˆç”¨äºTREE/SCATTERæ¨¡å¼ï¼‰ ==========
    const dIndex = Math.hypot(indexTip.x - wrist.x, indexTip.y - wrist.y);
    const dMiddle = Math.hypot(middleTip.x - wrist.x, middleTip.y - wrist.y);
    const dRing = Math.hypot(ringTip.x - wrist.x, ringTip.y - wrist.y);
    const dPinky = Math.hypot(pinkyTip.x - wrist.x, pinkyTip.y - wrist.y);
    const avgSpread = (dIndex + dMiddle + dRing + dPinky) / 4;
    const isPalmOpen = avgSpread > CONFIG.gestures.palmOpenThreshold;

    // ========== 4. æ ¸å¿ƒçŠ¶æ€æœºé€»è¾‘ ==========
    if (isPinching) {
    // FOCUSæ¨¡å¼ï¼šPinchæåˆ â†’ åˆ‡æ¢ç…§ç‰‡/èšç„¦æ˜Ÿæ˜Ÿ
    STATE.mode = 'FOCUS';
    // è¿‡æ»¤æœ‰æ•ˆç…§ç‰‡ï¼ˆç¡®ä¿meshå­˜åœ¨ï¼‰
    const photos = particleSystem.filter(p => p.type === 'PHOTO' && p.mesh);
    console.log("æœ‰æ•ˆç…§ç‰‡åˆ—è¡¨ï¼š", photos.map((p, i) => `ç¬¬${i}å¼ ï¼š${p.mesh.name || 'æœªå‘½å'}`));
    console.log("å½“å‰å…¨å±€ç´¢å¼•ï¼š", window.photoIndex);

    // ä½ åŸæœ‰çš„pinchè§¦å‘é€»è¾‘ä½ç½®ï¼ˆæ¯”å¦‚onPinchå‡½æ•°å†…ï¼‰
// processGestureså‡½æ•°ä¸­çš„pinché€»è¾‘å®Œæ•´ä¿®å¤ç‰ˆ
if (isJustPinched && window.photos && window.photos.length > 0) {
  if (!window.photoHistory) window.photoHistory = [];
  
  let randomIndex;
  let isReward = false;

  // 1. ç­›é€‰å¥–åŠ±/æ™®é€šå›¾ç‰‡ç´¢å¼•
  const rewardIndexes = [];
  window.photos.forEach((photo, idx) => {
    if (photo.type === 'REWARD' && Math.random() <= photo.probability) {
      rewardIndexes.push(idx);
    }
  });
  const normalIndexes = window.photos.reduce((acc, photo, idx) => {
    if (photo.type === 'NORMAL') acc.push(idx);
    return acc;
  }, []);

  // 2. ç¡®å®šå€™é€‰åˆ—è¡¨ï¼ˆå…œåº•é€»è¾‘ï¼‰
  let finalCandidates = rewardIndexes.length > 0 ? rewardIndexes : normalIndexes;
  if (finalCandidates.length === 0) finalCandidates = [0]; // ç»ˆæå…œåº•

  // 3. é€‰ç´¢å¼•ï¼ˆæ’é™¤å†å²ï¼‰
  if (finalCandidates.length === 1) {
    randomIndex = finalCandidates[0];
  } else {
    do {
      randomIndex = finalCandidates[Math.floor(Math.random() * finalCandidates.length)];
    } while (window.photoHistory.includes(randomIndex));
  }

  // 4. æ ¡éªŒselectedå’Œmeshï¼ˆæ ¸å¿ƒï¼šè§£å†³meshæœªå®šä¹‰ï¼‰
  const selected = window.photos[randomIndex] || window.photos[0]; // å…œåº•
  if (selected && selected.mesh) {
    // è§¦å‘ç‰¹æ•ˆï¼ˆä½¿ç”¨selected.meshï¼Œè€Œéå•ç‹¬çš„meshï¼‰
    if (selected.type === 'REWARD') {
      isReward = true;
      triggerRewardEffect(selected.mesh, selected.probability);
    } else {
      triggerNormalEffect(selected.mesh);
    }
    // æ›´æ–°èšç„¦
    STATE.focusTarget = selected.mesh;
  } else {
    console.warn('âš ï¸ ç…§ç‰‡meshæœªå®šä¹‰ï¼Œç´¢å¼•ï¼š', randomIndex);
    STATE.focusTarget = STATE.starMesh; // å…œåº•èšç„¦æ˜Ÿæ˜Ÿ
  }

  // 5. æ›´æ–°å†å²è®°å½•
  window.photoIndex = randomIndex;
  window.photoHistory.push(randomIndex);
  if (window.photoHistory.length > 2) window.photoHistory.shift();

  // æ—¥å¿—
  console.log(isReward ? 
    `ğŸ‰ è§¦å‘å¥–åŠ±å›¾ç‰‡ï¼šåç§°=${selected?.name || 'æœªçŸ¥'}` : 
    `ğŸ”„ è§¦å‘æ™®é€šå›¾ç‰‡ï¼šåç§°=${selected?.name || 'æœªçŸ¥'}`
  );
} else if (window.photos?.length === 0) {
  STATE.focusTarget = STATE.starMesh;
  console.log("ğŸ“­ æ— ç…§ç‰‡ï¼Œèšç„¦æ˜Ÿæ˜Ÿ");
}

// èšç„¦æ—¶åœæ­¢æ—‹è½¬
STATE.hasPalmCenter = false;
STATE.spinVel.x *= 0.9;
STATE.spinVel.y *= 0.9;
	}else {
        // TREE/SCATTERæ¨¡å¼ï¼šéPinchçŠ¶æ€ â†’ æ‰‹æŒæ§åˆ¶æ—‹è½¬
        STATE.wasPointing = false; // å…¼å®¹åŸæœ‰æŒ‡ç‚¹æ‰‹åŠ¿çš„çŠ¶æ€é‡ç½®

        if (isPalmOpen) {
            // SCATTERæ¨¡å¼ï¼šæ‰‹æŒå¼ å¼€ â†’ æ‰‹åŠ¨æ§åˆ¶æ—‹è½¬
            if (STATE.mode !== 'SCATTER' || !STATE.hasPalmCenter) {
                STATE.palmCenter.x = palm.x;
                STATE.palmCenter.y = palm.y;
                STATE.hasPalmCenter = true;
            }
            STATE.mode = 'SCATTER';
			
            const dx = palm.x - STATE.palmCenter.x;
            const dy = palm.y - STATE.palmCenter.y;
            const gain = CONFIG.gestures.sensitivity;
            const maxSpeed = 3.0;

            const targetVelY = THREE.MathUtils.clamp(dx * gain, -maxSpeed, maxSpeed);
            const targetVelX = THREE.MathUtils.clamp(-dy * gain, -maxSpeed, maxSpeed);

            // å¹³æ»‘é€Ÿåº¦å˜åŒ–
            STATE.spinVel.x += (targetVelX - STATE.spinVel.x) * 0.2;
            STATE.spinVel.y += (targetVelY - STATE.spinVel.y) * 0.2;
        } else {
            // TREEæ¨¡å¼ï¼šæ‰‹æŒæ”¾æ¾ â†’ è‡ªåŠ¨æ—‹è½¬
            STATE.mode = 'TREE';
            STATE.hasPalmCenter = false;
            STATE.spinVel.x *= 0.9;
            STATE.spinVel.y *= 0.9;
        }

        // æ›´æ–°æ‰‹çš„ä½ç½®ï¼ˆä»…éFOCUSæ¨¡å¼ä¸‹ï¼‰
        const targetX = (palm.x - 0.5) * 3.0;
        const targetY = (palm.y - 0.5) * 3.0;
        STATE.hand.x += (targetX - STATE.hand.x) * 0.1;
        STATE.hand.y += (targetY - STATE.hand.y) * 0.1;
    }

    // ========== 5. ä¿å­˜ä¸Šä¸€å¸§PinchçŠ¶æ€ï¼ˆä¾›ä¸‹ä¸€å¸§åˆ¤æ–­ï¼‰ ==========
    window.lastPinch = isPinching;
}

		/**
 * é€šç”¨å·¥å…·å‡½æ•°ï¼šé‡ç½®ç…§ç‰‡æè´¨ä¸ºã€Œä½åå…‰+äº®åº¦è¡¥å¿ã€æ¨¡å¼
 * @param {THREE.Group} mesh - ç…§ç‰‡Groupå®¹å™¨
 * @param {number} brightness - äº®åº¦è¡¥å¿å€¼ï¼ˆ0~2ï¼Œé»˜è®¤1.2ï¼Œè¶Šé«˜è¶Šäº®ï¼‰
 */
function resetPhotoMaterialForLowReflect(mesh, brightness = 7) {
  if (!mesh) return;
  mesh.traverse((child) => {
    if (child.isMesh) {
      const mat = child.material;
      // 1. å…³é—­è‡ªå‘å…‰ï¼ˆæ ¸å¿ƒï¼Œä¸æ”¹åŠ¨ï¼‰
      mat.emissive.setHex(0x000000);
      mat.emissiveIntensity = 0.2;
      
      // 2. ä½åå…‰å‚æ•°ï¼ˆé€‚åº¦æ”¾å®½ï¼Œæå‡äº®åº¦ï¼‰
      if (mat instanceof THREE.MeshStandardMaterial || mat instanceof THREE.MeshPhysicalMaterial) {
        mat.roughness = 0.6;        // ä»1.0é™åˆ°0.8ï¼ˆè½»å¾®åå…‰ï¼Œæå‡äº®åº¦ï¼‰
        mat.metalness = 0.9;        // ä»0.0å‡åˆ°0.1ï¼ˆæè½»å¾®é‡‘å±æ„Ÿï¼Œæå‡äº®åº¦ï¼‰
        mat.specularIntensity = 0.3;// ä»0.0å‡åˆ°0.1ï¼ˆæè½»å¾®é«˜å…‰ï¼‰
        mat.clearcoat = 0;          
        mat.clearcoatRoughness = 1;
        mat.envMapIntensity = 0.7;  // ä»0.0å‡åˆ°0.1ï¼ˆè½»å¾®ç¯å¢ƒåå…‰ï¼‰
        
        // æ ¸å¿ƒï¼šæè´¨é¢œè‰²äº®åº¦è¡¥å¿ï¼ˆä¸è§¦å‘åå…‰ï¼‰
        mat.color.offsetHSL(0, 0, brightness - 1); // åªè°ƒäº®åº¦é€šé“
        mat.needsUpdate = true;
      }
      
      // 3. é’ˆå¯¹åŸºç¡€æè´¨ï¼šç›´æ¥æå‡é¢œè‰²äº®åº¦
      if (mat instanceof THREE.MeshBasicMaterial) {
        mat.lights = false; // ä»å±è”½åœºæ™¯å…‰ï¼ˆå…³é”®ï¼‰
        // äº®åº¦è¡¥å¿ï¼ˆæ¯”å¦‚1.2=æå‡20%äº®åº¦ï¼‰
        const currentColor = mat.color.clone();
        currentColor.multiplyScalar(brightness);
        mat.color = currentColor;
        mat.needsUpdate = true;
      }
    }
  });
}
		

		/// æ™®é€šç…§ç‰‡ç‰¹æ•ˆï¼ˆåŸºç¡€æ”¾å¤§+å¼±å‘å…‰ï¼‰
// æ™®é€šç…§ç‰‡ç‰¹æ•ˆï¼ˆä»…ä¿ç•™ç¼©æ”¾ï¼Œå®Œå…¨ç§»é™¤å‘å…‰é€»è¾‘ï¼‰
function triggerNormalEffect(mesh) {
  // é˜²å¾¡æ€§æ ¡éªŒï¼šmeshä¸å­˜åœ¨ç›´æ¥è¿”å›
  if (!mesh) {
    console.warn('æ™®é€šç‰¹æ•ˆè§¦å‘å¤±è´¥ï¼šmeshä¸ºç©º');
    return;
  }

  // ä»…ä¿ç•™æ™®é€šç…§ç‰‡æ”¾å¤§é€»è¾‘
  mesh.scale.lerp(new THREE.Vector3(5, 5, 5), 0.1);
  
  // æ¸…é™¤æ®‹ç•™çš„å¥–åŠ±ç‰¹æ•ˆå®šæ—¶å™¨ï¼ˆé¿å…å†²çªï¼‰
  if (mesh.rewardPulseInterval) {
    clearInterval(mesh.rewardPulseInterval);
    mesh.rewardPulseInterval = null;
  }
}
/**
 * å¥–åŠ±ç…§ç‰‡ä¸“å±ç‰¹æ•ˆï¼ˆä»…ä¿ç•™ç¼©æ”¾+è„‰å†²+ç²’å­+UIæç¤ºï¼Œç§»é™¤å‘å…‰ï¼‰
 * @param {THREE.Group} mesh - ç…§ç‰‡çš„Groupå®¹å™¨
 * @param {number} probability - å¥–åŠ±è§¦å‘æ¦‚ç‡
 */
/**
 * å¥–åŠ±ç…§ç‰‡ä¸“å±ç‰¹æ•ˆï¼ˆå½»åº•è§£å†³åå…‰+ä¿ç•™ç›¸æ¡†å‘å…‰ï¼‰
 * @param {THREE.Group} mesh - ç…§ç‰‡çš„Groupå®¹å™¨
 * @param {number} probability - å¥–åŠ±è§¦å‘æ¦‚ç‡
 */
function triggerRewardEffect(mesh, probability) {
  // é˜²å¾¡æ€§æ ¡éªŒ
  if (!mesh || typeof probability !== 'number') {
    console.warn('å¥–åŠ±ç‰¹æ•ˆè§¦å‘å¤±è´¥ï¼šå‚æ•°æ— æ•ˆ');
    return;
  }

 // ========== âœ… ã€æ–°å¢æ ¸å¿ƒã€‘GA4 å¥–åŠ±æ•è·äº‹ä»¶ä¸ŠæŠ¥ â€”â€” æ”¾åœ¨æœ€é¡¶éƒ¨ ==========
  if (window.gtag) { // å…¼å®¹ï¼šå¦‚æœgtagæœªåŠ è½½ï¼Œä¸æŠ¥é”™
    gtag('event', 'christmas_reward_caught', {
      // äº‹ä»¶æ ¸å¿ƒå‚æ•°ï¼ˆå¯åœ¨GA4åå°ç­›é€‰/ç»Ÿè®¡ï¼‰
      event_category: 'ç”¨æˆ·äº¤äº’',
      event_label: 'åœ£è¯å¥–åŠ±å›¾æ•è·',
      reward_probability: probability, // æ•è·çš„å¥–åŠ±æ¦‚ç‡ï¼ˆ0.002ï¼‰
      reward_type: 'ç¨€æœ‰å¥–åŠ±', // å¯è‡ªå®šä¹‰ï¼šæ¯”å¦‚åŒºåˆ†ä¸åŒå¥–åŠ±å›¾å†™'reward1/reward2/reward3'
      value: 1 // è®¡æ•°ç”¨ï¼Œå›ºå®šä¼ 1å³å¯
    });
    console.log('ğŸ“Š GA4å¥–åŠ±äº‹ä»¶å·²ä¸ŠæŠ¥ï¼Œæ¦‚ç‡ï¼š', probability);
  }
  // ========== GA4 ä¸ŠæŠ¥ä»£ç ç»“æŸ ==========

  // ========== æ–°å¢ï¼šå¥–åŠ±è§¦å‘åå†»ç»“äº¤äº’ ==========
  window.isRewardFrozen = true; // å…¨å±€æ ‡è®°ï¼šå†»ç»“çŠ¶æ€
  const freezeOverlay = document.getElementById('rewardFreezeOverlay');
  // ğŸ”¥ æ ¸å¿ƒä¿®æ”¹ï¼šæ›¿æ¢ç›´æ¥æ”¹displayï¼Œæ”¹ä¸ºæ·»åŠ .showç±»ï¼ˆåŒ¹é…CSSé€»è¾‘ï¼‰
  if (freezeOverlay) freezeOverlay.classList.add('show'); // ä¸å†ç”¨style.display = 'flex'

  // ========== æ ¸å¿ƒä¿®å¤1ï¼šå…ˆé‡ç½®ç…§ç‰‡æè´¨ä¸ºä½åå…‰æ¨¡å¼ ==========
  resetPhotoMaterialForLowReflect(mesh,4);

  // ========== æ ¸å¿ƒä¿®å¤2ï¼šä¸´æ—¶é™ä½ç…§ç‰‡å‘¨å›´åœºæ™¯å…‰ï¼ˆå‡å°‘ç¼©æ”¾åå…‰ï¼‰ ==========
  const originalLightIntensities = [];
  if (typeof scene !== 'undefined' && scene) {
    scene.traverse((obj) => {
      if (obj.isLight && obj.intensity > 0) {
        originalLightIntensities.push({
          light: obj,
          intensity: obj.intensity
        });
        // åªé™ä½ç…§ç‰‡15å•ä½å†…çš„å…‰æºï¼ˆç¼©å°èŒƒå›´ï¼Œé¿å…å½±å“å…¨å±€ï¼‰
        const distance = obj.position.distanceTo(mesh.position);
        if (distance < 15) {
          obj.intensity *= 1.8; // å¼ºåº¦é™ä¸º40%ï¼ˆæ¯”ä¹‹å‰æ›´ä¿å®ˆï¼Œå‡å°‘åå…‰ï¼‰
        }
      }
    });
  }

  // 1. å¥–åŠ±ç…§ç‰‡ç¼©æ”¾+è„‰å†²åŠ¨ç”»ï¼ˆé€‚åº¦ç¼©å°ï¼Œå‡å°‘å—å…‰é¢ç§¯ï¼‰
  mesh.scale.set(6, 6, 6); // åˆå§‹å°ºå¯¸æ›´å°ï¼Œå‡å°‘åå…‰åŸºç¡€
  gsap.to(mesh.scale, { x: 7, y: 7, z: 7, duration: 0.3, ease: 'power2.out' });
  gsap.to(mesh.scale, { x: 6.5, y: 6.5, z: 6.5, duration: 0.2, delay: 0.3, ease: 'power2.in' });
  
  // å¾ªç¯è„‰å†²ï¼ˆåŒæ­¥ç¼©å°ï¼Œé¿å…è¿‡åº¦æ”¾å¤§ï¼‰
  if (mesh.rewardPulseInterval) clearInterval(mesh.rewardPulseInterval);
  mesh.rewardPulseInterval = setInterval(() => {
    gsap.to(mesh.scale, { x: 7, y: 7, z: 7, duration: 0.2, ease: 'power1.out' });
    gsap.to(mesh.scale, { x: 6.5, y: 6.5, z: 6.5, duration: 0.2, delay: 0.2, ease: 'power1.in' });
  }, 800);
  
  setTimeout(() => {
    if (mesh.rewardPulseInterval) {
      clearInterval(mesh.rewardPulseInterval);
      mesh.rewardPulseInterval = null;
      // ç»“æŸåå›å¼¹åˆ°æ­£å¸¸å¤§å°
      gsap.to(mesh.scale, { x: 5, y: 5, z: 5, duration: 0.5, ease: 'elastic.out(1, 0.3)' });
    }

    // ç‰¹æ•ˆç»“æŸåæ¢å¤åœºæ™¯å…‰å¼ºåº¦
    originalLightIntensities.forEach(item => {
      if (item.light && typeof item.light.intensity !== 'undefined') {
        item.light.intensity = item.intensity;
      }
    });
  }, 4000);

  // 2. ç›¸æ¡†å‘å…‰ï¼ˆä»…ç›¸æ¡†ï¼Œç…§ç‰‡ä¸å‘å…‰ï¼‰
  mesh.traverse((child) => {
    // ä¼˜å…ˆåŒ¹é…ç›¸æ¡†æ ‡è¯†ï¼Œæ— æ ‡è¯†åˆ™ç”¨BoxGeometryï¼ˆå…¼å®¹åŸæœ‰é€»è¾‘ï¼‰
    const isFrame = child.userData.isPhotoFrame || (child.isMesh && child.geometry instanceof THREE.BoxGeometry);
    const isPhoto = !child.userData.isPhotoFrame && (child.isMesh && child.geometry instanceof THREE.PlaneGeometry);

    if (isFrame && !isPhoto) { // åªè®©ç›¸æ¡†å‘å…‰
      child.material.emissive.setHex(0xffff00);
      child.material.emissiveIntensity = 2.0;
      // ç›¸æ¡†å‘¼å¸å‘å…‰
      gsap.to(child.material, { 
        emissiveIntensity: 0.8, 
        duration: 2, 
        repeat: -1, 
        yoyo: true, 
        ease: 'power1.inOut' 
      });
      // 4ç§’ååœæ­¢å‘å…‰
      setTimeout(() => {
        gsap.to(child.material, { emissiveIntensity: 0, duration: 1 });
      }, 4000);
    }
    // å…œåº•ï¼šç¡®ä¿ç…§ç‰‡ä¸å‘å…‰
    if (isPhoto) {
      child.material.emissiveIntensity = 0.3;
      child.material.emissive.setHex(0x000000);
    }
  });

  // 3. é‡‘è‰²æ˜Ÿå°˜ç²’å­ç‰¹æ•ˆï¼ˆä¿ç•™ï¼‰
  if (typeof createRewardParticles === 'function') {
    createRewardParticles(mesh.position);
    setTimeout(() => createRewardParticles(mesh.position, true), 500);
  }

  // 4. å±å¹•UIæç¤ºï¼ˆä¿ç•™ï¼‰
  if (typeof showRewardTip === 'function') {
    showRewardTip(probability);
  }

  // 5. å…¨å±é—ªå…‰ç‰¹æ•ˆï¼ˆä¿ç•™ï¼‰
  createScreenFlash();

  // 6. éŸ³æ•ˆï¼ˆå¯é€‰ï¼‰
  // playRewardSound();
}

// å‡çº§ï¼šå¥–åŠ±æ˜Ÿå°˜ç²’å­ï¼ˆå¤šå½¢æ€+å¤šæ³¢æ¬¡+è½¨è¿¹ï¼‰
function createRewardParticles(centerPos, isBig = false) {
  const particleCount = isBig ? 40 : 100; // å¤§ç²’å­æ•°é‡å°‘ï¼Œå°ç²’å­æ•°é‡å¤š
  const size = isBig ? 0.3 : 0.15; // å¤§ç²’å­å°ºå¯¸æ›´å¤§
  const range = isBig ? 18 : 12; // å¤§ç²’å­æ‰©æ•£èŒƒå›´æ›´å¹¿

  for (let i = 0; i < particleCount; i++) {
    const geo = new THREE.SphereGeometry(size, 12, 12); // æ›´é«˜ç²¾åº¦ï¼Œæ›´åœ†æ¶¦
    // æ¸å˜é‡‘è‰²ï¼Œå¢åŠ å±‚æ¬¡æ„Ÿ
    const goldColor = new THREE.Color(0xffff00);
    goldColor.offsetHSL(0, 0, Math.random() * 0.3); // éšæœºäº®åº¦
    const mat = new THREE.MeshBasicMaterial({ 
      color: goldColor, 
      transparent: true, 
      opacity: 0.9,
      blending: THREE.AdditiveBlending // å åŠ æ··åˆï¼Œæ›´äº®æ›´é€šé€
    });
    const particle = new THREE.Mesh(geo, mat);
    
    // åˆå§‹ä½ç½®ï¼ˆçƒå½¢æ‰©æ•£ï¼‰
    particle.position.copy(centerPos);
    particle.position.x += (Math.random() - 0.5) * range;
    particle.position.y += (Math.random() - 0.5) * range;
    particle.position.z += (Math.random() - 0.5) * range;

    // åˆå§‹ç¼©æ”¾åŠ¨ç”»ï¼ˆç²’å­å‡ºç”Ÿæ—¶æ”¾å¤§ï¼‰
    particle.scale.set(0, 0, 0);
    gsap.to(particle.scale, { x: 1, y: 1, z: 1, duration: 0.3, ease: 'power2.out' });
    
    mainGroup.add(particle);

    // è½¨è¿¹åŠ¨ç”»ï¼ˆå‡çº§ï¼šæ›²çº¿è¿åŠ¨+éšæœºæ–¹å‘ï¼‰
    const targetX = particle.position.x + (Math.random() - 0.5) * (isBig ? 15 : 8);
    const targetY = particle.position.y + (Math.random() - 0.5) * (isBig ? 15 : 8);
    const targetZ = particle.position.z + (Math.random() - 0.5) * (isBig ? 15 : 8);
    gsap.to(particle.position, { 
      x: targetX, 
      y: targetY, 
      z: targetZ, 
      duration: isBig ? 3.5 : 2.5, 
      ease: 'power2.out' 
    });

    // é€æ˜åº¦+ç¼©æ”¾æ·¡å‡ºï¼ˆå‡çº§ï¼šå…ˆäº®åæš—ï¼Œå¸¦é—ªçƒï¼‰
    gsap.to(particle.material, { 
      opacity: 0, 
      duration: isBig ? 3.5 : 2.5,
      onUpdate: () => {
        // éšæœºé—ªçƒæ•ˆæœ
        if (Math.random() > 0.95) {
          particle.material.opacity = Math.random() * 0.8 + 0.2;
        }
      },
      onComplete: () => {
        mainGroup.remove(particle);
        particle.geometry.dispose(); // é‡Šæ”¾å†…å­˜
        particle.material.dispose();
      }
    });
  }
}

// å‡çº§ï¼šå¥–åŠ±UIæç¤ºï¼ˆåŠ¨ç”»å…¥åœº+æ–‡å­—ç‰¹æ•ˆ+èƒŒæ™¯å…‰æ™•ï¼‰
// é€‚é…å•ç§éšè—å¥–åŠ±ï¼šçº¯è‹±æ–‡æç¤ºï¼ˆæ— åŒºåˆ†ï¼Œç»Ÿä¸€é…·ç‚«æ•ˆæœï¼‰
function showRewardTip(probability) {
  const tip = document.createElement('div');
  // 1. æ·»åŠ ç±»åï¼Œç”¨äºCSSåŒºåˆ†PC/ç§»åŠ¨ç«¯
  tip.className = 'reward-tip';
  const enText = 'ğŸ æ­å–œä½ ï¼ŒæŠ“åˆ°äº†é©šå–œçå‹µ';
  
  // 2. ä»…ä¿ç•™æ ¸å¿ƒå®šä½/å±‚çº§æ ·å¼ï¼ˆæ— æ³•ç”¨åª’ä½“æŸ¥è¯¢æ§åˆ¶çš„éƒ¨åˆ†ï¼‰
  tip.style.cssText = `
    position: fixed; 
    top: 50%; 
    left: 50%; 
    transform: translate(-50%, -50%) scale(1);
    z-index: 1000000; 
    pointer-events: none;
    opacity: 1;
  `;
  
  // 3. æ–‡å­—å†…å®¹ï¼ˆç§»é™¤å†…è”font-sizeï¼Œäº¤ç»™CSSæ§åˆ¶ï¼‰
  tip.innerHTML = `<span class="reward-tip-text">${enText}</span>`;
  
  document.body.appendChild(tip);
  console.log('âœ… å¥–åŠ±æ–‡å­—å·²åˆ›å»ºï¼ŒDOMèŠ‚ç‚¹ï¼š', tip);
  
  // ä¿ç•™åŸæœ‰GSAPåŠ¨ç”»é€»è¾‘ï¼ˆå®Œå…¨ä¸å˜ï¼‰
  gsap.to(tip, {
    scale: 1.2, 
    duration: 0.5, 
    ease: 'power2.out',
    onComplete: () => {
      gsap.to(tip, { scale: 1, duration: 0.2, ease: 'power2.in' });
    }
  });
  
  let flashInterval = setInterval(() => {
    tip.style.opacity = Math.random() > 0.5 ? 1 : 0.8;
  }, 200);
  
  setTimeout(() => {
    clearInterval(flashInterval);
    gsap.to(tip, { 
      opacity: 0, 
      scale: 0.8,
      duration: 1.2, 
      ease: 'power2.inOut',
      onComplete: () => document.body.removeChild(tip)
    });
  }, 3000);
}
// æ–°å¢ï¼šå…¨å±é—ªå…‰ç‰¹æ•ˆ
function createScreenFlash() {
  const flash = document.createElement('div');
  flash.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(255,255,255,0.8);
    z-index: 999998;
    pointer-events: none;
    opacity: 0;
  `;
  document.body.appendChild(flash);
  
  // é—ªå…‰åŠ¨ç”»ï¼ˆå¿«é€Ÿé—ªä¸€ä¸‹ï¼‰
  gsap.to(flash.style, { 
    opacity: 1, 
    duration: 0.1, 
    ease: 'power1.out',
    onComplete: () => {
      gsap.to(flash.style, { 
        opacity: 0, 
        duration: 0.5, 
        ease: 'power1.in',
        onComplete: () => document.body.removeChild(flash)
      });
    }
  });
}

// å¯é€‰ï¼šå¥–åŠ±éŸ³æ•ˆ
// function playRewardSound() {
//   const audio = new Audio('./assets/audio/reward.mp3');
//   audio.volume = 0.8;
//   audio.play().catch(err => console.error('éŸ³æ•ˆæ’­æ”¾å¤±è´¥ï¼š', err));
// }

        // ==========================================
        // 8. åŠ¨ç”»å¾ªç¯ & DOM äº‹ä»¶
        // ==========================================
       // 8. åŠ¨ç”»å¾ªç¯ & DOM äº‹ä»¶
        function animate() {
    requestAnimationFrame(animate);

    const dt = clock.getDelta();
    STATE.time = clock.elapsedTime;
    const currentTimeMs = STATE.time * 1000; // å½“å‰æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰

    // æ ¸å¿ƒï¼šæœªå¯åŠ¨åœºæ™¯ æˆ– æ‘„åƒå¤´æœªåˆå§‹åŒ– â†’ ç¦ç”¨æ‰‹åŠ¿åŠ¨ç”»ï¼Œä½†ç»§ç»­æ¸²æŸ“
    if (!window.isSceneStarted) {
        // æ£€æŸ¥ç²’å­æ˜¯å¦å½’ä½å®Œæˆï¼ˆä»…åœ¨æœªå¯åŠ¨åœºæ™¯æ—¶åˆ¤æ–­ï¼‰
        if (!ANIMATION_STATE.treeSettleComplete) {
            checkTreeSettle(currentTimeMs); // æ–°å¢ï¼šæ£€æŸ¥å½’ä½
        }
        composer.render();
        return;
    }

    // æ‰‹åŠ¿ç›¸å…³åŠ¨ç”»é€»è¾‘ï¼ˆåŸæœ‰ä»£ç ä¸å˜ï¼‰
    let inputX = STATE.hand.detected ? STATE.hand.x : STATE.mouse.x * 0.5;
    if (STATE.mode === 'TREE') {
        STATE.rotation.y -= 0.4 * dt; 
        STATE.rotation.x = THREE.MathUtils.lerp(STATE.rotation.x, 0.15, dt * 2.0);
        mainGroup.rotation.z = THREE.MathUtils.lerp(mainGroup.rotation.z, inputX * 0.1, dt * 2);
    } 
    else if (STATE.mode === 'SCATTER') {
        STATE.rotation.y += STATE.spinVel.y * dt;
        STATE.rotation.x += STATE.spinVel.x * dt;
        if (!STATE.hand.detected) {
            STATE.spinVel.x *= 0.95;
            STATE.spinVel.y *= 0.95;
        }
    }

    mainGroup.rotation.y = STATE.rotation.y;
    mainGroup.rotation.x = STATE.rotation.x;
    bgGroup.rotation.y -= 0.05 * dt;

    if (STATE.starMesh) {
        STATE.starMesh.rotation.y -= dt;
        STATE.starMesh.rotation.z = Math.sin(STATE.time) * 0.2;
        const scale = 1.0 + Math.sin(STATE.time * 2) * 0.1;
        STATE.starMesh.scale.set(scale, scale, scale);
    }
	if (snowSystem && snowSystem.visible) {
    console.log('âœ… é›ªèŠ±åŠ¨ç”»æ­£åœ¨æ‰§è¡Œï¼'); // æ ¸å¿ƒéªŒè¯æ—¥å¿—
    const positions = snowSystem.geometry.attributes.position.array;
    const velocities = snowSystem.geometry.attributes.velocity.array;
    const count = CONFIG.particles.snowCount || 2500;

    for (let i = 0; i < count; i++) {
        positions[i * 3 + 1] -= velocities[i] * dt* 6; 
        positions[i * 3] += Math.sin(STATE.time * 0.5 + i) * 0.1; 
        if (positions[i * 3 + 1] < -50) {
            positions[i * 3 + 1] = 100; 
            positions[i * 3] = (Math.random() - 0.5) * 200;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 150;
        }
    }
    snowSystem.geometry.attributes.position.needsUpdate = true;
} else {
    console.log('âŒ é›ªèŠ±åŠ¨ç”»æœªæ‰§è¡Œï¼šsnowSystemä¸å­˜åœ¨/ä¸å¯è§');
}

    // ==========================================
    // é›ªèŠ±ä»£ç ç»“æŸ
    // ==========================================
    for(let i=0, l=particleSystem.length; i<l; i++){
        particleSystem[i].update(dt, STATE.time, STATE.mode, STATE.focusTarget);
    }

    composer.render();
}

// æ–°å¢ï¼šæ£€æŸ¥åœ£è¯æ ‘ç²’å­æ˜¯å¦å½’ä½å®Œæˆ
function checkTreeSettle(currentTimeMs) {
    // 1. è¶…æ—¶å…œåº•ï¼ˆå»¶é•¿åˆ°4ç§’ï¼Œç»™ç²’å­è¶³å¤Ÿçš„åŠ¨ç”»æ—¶é—´ï¼‰
    if (currentTimeMs - ANIMATION_STATE.settleCheckTime > ANIMATION_STATE.settleDelay) {
        console.log('âœ… ç²’å­å½’ä½è¶…æ—¶ï¼Œå¼€å§‹å¹³æ»‘å½’ä½åŠ¨ç”»');
        // å¯åŠ¨å¹³æ»‘å½’ä½åŠ¨ç”»ï¼ˆè€Œéç¬é—´ç¬ç§»ï¼‰
        startSmoothSettleAnimation();
        ANIMATION_STATE.treeSettleComplete = true;
        return;
    }

    // 2. å…¨é‡æ£€æŸ¥ï¼ˆåˆ¤æ–­æ˜¯å¦éœ€è¦å½’ä½ï¼‰
    let allInPlace = true;
    let maxError = 0;
    for (let i = 0; i < particleSystem.length; i++) {
        const p = particleSystem[i];
        if (p.type === 'DUST') continue;
        
        const error = p.mesh.position.distanceTo(p.posTree);
        maxError = Math.max(maxError, error);
        if (error > 0.05) {
            allInPlace = false;
            break;
        }
    }

    // 3. æ‰€æœ‰ç²’å­æ¥è¿‘å½’ä½ â†’ å¯åŠ¨æœ€ç»ˆå¹³æ»‘å¯¹é½ï¼ˆé¿å…å¾®å°æ™ƒåŠ¨ï¼‰
    if (allInPlace) {
        startSmoothSettleAnimation(0.2); // å¿«é€Ÿå¹³æ»‘ï¼ˆ0.2ç§’ï¼‰
        ANIMATION_STATE.treeSettleComplete = true;
        console.log(`âœ… ç²’å­æ¥è¿‘å½’ä½ï¼Œæœ€å¤§è¯¯å·®ï¼š${maxError.toFixed(4)}ï¼Œå¼€å§‹æœ€ç»ˆå¹³æ»‘å¯¹é½`);
    }
}

		// å¹³æ»‘å½’ä½åŠ¨ç”»ï¼šç²’å­åœ¨æŒ‡å®šæ—¶é—´å†… lerp åˆ°ç›®æ ‡ä½ç½®
function startSmoothSettleAnimation(duration = 3) {
    // è®°å½•åŠ¨ç”»å¼€å§‹æ—¶é—´
    const startTime = Date.now();
    const animationDuration = duration * 1000; // è½¬æ¯«ç§’

    // åŠ¨ç”»å¾ªç¯å‡½æ•°
    function animateSettle() {
        // è®¡ç®—åŠ¨ç”»è¿›åº¦ï¼ˆ0-1ï¼‰
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / animationDuration, 1);

        // å¯¹æ¯ä¸ªéæ˜Ÿå°˜ç²’å­è¿›è¡Œå¹³æ»‘æ’å€¼
        for (let i = 0; i < particleSystem.length; i++) {
            const p = particleSystem[i];
            if (p.type === 'DUST') continue;

            // çº¿æ€§æ’å€¼åˆ°ç›®æ ‡ä½ç½®ï¼ˆprogress=1æ—¶å®Œå…¨å½’ä½ï¼‰
            p.mesh.position.lerp(p.posTree, progress);
            // åŒæ—¶å¹³æ»‘æ¢å¤åŸºç¡€å°ºå¯¸
            p.mesh.scale.lerp(new THREE.Vector3(p.baseScale, p.baseScale, p.baseScale), progress);
        }

        // åŠ¨ç”»æœªå®Œæˆåˆ™ç»§ç»­å¾ªç¯
        if (progress < 1) {
            requestAnimationFrame(animateSettle);
        } else {
            console.log('âœ… ç²’å­å¹³æ»‘å½’ä½åŠ¨ç”»å®Œæˆ');
        }
    }

    // å¯åŠ¨åŠ¨ç”»
    requestAnimationFrame(animateSettle);
}
        function setupEvents() {
            // çª—å£è°ƒæ•´
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });

		

            

        
            // UI æŒ‰é’®: å…¨å±åˆ‡æ¢
            const fullscreenBtn = document.getElementById('btn-fullscreen');
            if (fullscreenBtn) {
                fullscreenBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (!document.fullscreenElement) {
                        document.documentElement.requestFullscreen().catch(err => console.warn(err));
                    } else {
                        if (document.exitFullscreen) document.exitFullscreen();
                    }
                });
                document.addEventListener('fullscreenchange', () => {
                // å¦‚æœå½“å‰æ˜¯å…¨å±çŠ¶æ€
                if (document.fullscreenElement) {
                    fullscreenBtn.textContent = 'é€€å‡ºå…¨å±'; 
                } else {
                    // å¦‚æœé€€å‡ºäº†å…¨å±
                    fullscreenBtn.textContent = 'å…¨å±é¡¯ç¤º'; 
                }
            });
            }

            // éŸ³ä¹æ’­æ”¾ (äº¤äº’è§¦å‘)
let musicPlayed = false; // æ”¹æ›´æ¸…æ™°çš„å˜é‡åï¼Œé¿å…å’ŒAudioContextæ··æ·†
const musicBtn = document.getElementById('music-play-btn'); // å…œåº•æŒ‰é’®

const startMusic = () => {
    const music = document.getElementById('bg-music');
    
    // 1. æ ¡éªŒéŸ³é¢‘æ ‡ç­¾æ˜¯å¦å­˜åœ¨
    if (!music) {
        console.error('éŸ³é¢‘æ ‡ç­¾ä¸å­˜åœ¨ï¼è¯·æ£€æŸ¥HTMLé‡Œæ˜¯å¦æœ‰idä¸ºbg-musicçš„audioæ ‡ç­¾');
        if (musicBtn) musicBtn.style.display = 'block'; // æ˜¾ç¤ºå…œåº•æŒ‰é’®
        return;
    }

    // 2. é¿å…é‡å¤æ’­æ”¾
    if (musicPlayed) return;

    // 3. é…ç½®éŸ³é¢‘
    music.volume = 0.5; // éŸ³é‡50%
    music.load(); // å¼ºåˆ¶é‡æ–°åŠ è½½ï¼ˆé¿å…ç¼“å­˜é—®é¢˜ï¼‰

    // 4. å°è¯•æ’­æ”¾
    music.play()
        .then(() => {
            musicPlayed = true;
            console.log('èƒŒæ™¯éŸ³ä¹æ’­æ”¾æˆåŠŸï¼');
            if (musicBtn) musicBtn.style.display = 'none'; // éšè—å…œåº•æŒ‰é’®
        })
        .catch(e => {
            console.error('æ’­æ”¾å¤±è´¥ï¼š', e);
            // æ’­æ”¾å¤±è´¥æ—¶æ˜¾ç¤ºå…œåº•æŒ‰é’®ï¼Œè®©ç”¨æˆ·æ‰‹åŠ¨ç‚¹
            if (musicBtn) musicBtn.style.display = 'block';
        });
};

			// ç»§ç»­æŒ‰é’®ç‚¹å‡»äº‹ä»¶ï¼šæ¢å¤äº¤äº’+éšè—æŒ‰é’®
document.getElementById('continueBtn').addEventListener('click', () => {
  // 1. å–æ¶ˆå†»ç»“æ ‡è®°
  window.isRewardFrozen = false;
  // 2. éšè—å†»ç»“å±‚+æŒ‰é’®
  const freezeOverlay = document.getElementById('rewardFreezeOverlay');
  if (freezeOverlay) {
    freezeOverlay.classList.remove('show');
  }
  // 3. å¯é€‰ï¼šæ’­æ”¾ç‚¹å‡»éŸ³æ•ˆï¼ˆå¢å¼ºä½“éªŒï¼‰
  // const clickAudio = new Audio('./assets/audio/click.mp3');
  // clickAudio.volume = 0.5;
  // clickAudio.play().catch(err => console.error('ç‚¹å‡»éŸ³æ•ˆå¤±è´¥ï¼š', err));
});
// ç›‘å¬é¦–æ¬¡ç‚¹å‡»/è§¦æ‘¸ï¼ˆåªè§¦å‘ä¸€æ¬¡ï¼‰
window.addEventListener('click', startMusic, { once: true });
window.addEventListener('touchstart', startMusic, { once: true });

// å…œåº•æŒ‰é’®çš„ç‚¹å‡»äº‹ä»¶ï¼ˆç”¨æˆ·æ‰‹åŠ¨è§¦å‘ï¼‰
if (musicBtn) {
    musicBtn.addEventListener('click', startMusic);
}

            // è§¦æ‘¸æ»‘åŠ¨å¤‡ç”¨æ–¹æ¡ˆ (æ— æ‘„åƒå¤´æ—¶)
            let touchStartX = 0;
            document.addEventListener('touchstart', e => { touchStartX = e.touches[0].clientX; });
            document.addEventListener('touchmove', e => {
                if(STATE.hand.detected) return; // ä¼˜å…ˆå“åº”æ‘„åƒå¤´
                const deltaX = e.touches[0].clientX - touchStartX;
                STATE.rotation.y += deltaX * 0.005;
                touchStartX = e.touches[0].clientX;
            });
        }

        // å¯åŠ¨ç¨‹åº
        init();
    </script>

    <script>
        function downloadHTML() {
            window.location.href = '/html2images/download/' + window.location.pathname.split('/').pop();
        }
        function closeDownloadBtn(event) {
            event.stopPropagation();
            document.getElementById('downloadContainer').classList.add('hidden');
        }
        // ç¯å¢ƒæ£€æµ‹ï¼šä»…åœ¨ç‰¹å®šç¯å¢ƒæ˜¾ç¤ºä¸‹è½½æŒ‰é’®
        if (window.location.protocol === 'file:' || window.location.hostname !== 'api.xupeidong.cn') {
            document.getElementById('downloadContainer').classList.add('hidden');
        }
    </script>
</body>
</html>
